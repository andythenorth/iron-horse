<!--! Appearance that changes depending on position in formation.
      Intended for pax and mail cars, possibly limited other types.
      - loaded and empty state are same, but loading state is provided (for opening doors at stations)
      - open doors are comped in by the graphics processor
      - most sprites are symmetric, except, e.g. brake coaches; if vehicle is flipped in depot, any asymmetric sprite will be flipped
 -->

<!--! default graphics chain -->
<tal:formation_position_rules repeat="formation_position_rule_num python:range(model_variant.gestalt_graphics.num_unique_formation_positions)">
    spriteset(${unit.id}_ss_doors_closed_formation_position_rule_${formation_position_rule_num}, "${graphics_path}${model_variant.model_id}.png") {
        ${unit.get_spriteset_template_name('unreversed', 10 + (formation_position_rule_num * model_variant.gestalt_graphics.num_spritesheet_liveries_per_formation_position * 60) + (model_variant.catalogue_entry.livery_def.relative_spriterow_num * 60))}
    }
    spriteset(${unit.id}_ss_doors_open_formation_position_rule_${formation_position_rule_num}, "${graphics_path}${model_variant.model_id}.png") {
        ${unit.get_spriteset_template_name('unreversed', 10 + (formation_position_rule_num * model_variant.gestalt_graphics.num_spritesheet_liveries_per_formation_position * 60) + (model_variant.catalogue_entry.livery_def.relative_spriterow_num * 60) + 30)}
    }
    <!--! in case there wasn't enough complexity here, let's do pantographs too, in a separate layer -->
    <tal:pantographs condition="model_variant.pantograph_type is not None">
        <!--! !! the y base offsets here won't work for multi-unit vehicles, they need a different calculation -->
        <tal:pantographs repeat="pantograph_state ['down', 'up']">
            spriteset(${unit.id}_ss_pantographs_${pantograph_state}_${formation_position_rule_num}, "${graphics_path}${model_variant.model_id}_pantographs_${pantograph_state}.png") {
                ${unit.get_spriteset_template_name('unreversed', 10 + (formation_position_rule_num * 30))}
            }
        </tal:pantographs>
        switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_pantographs_state_${formation_position_rule_num}, ${model_variant.nml_expression_for_vehicle_is_electrically_powered_by_tile()}) {
            1: return ${unit.id}_ss_pantographs_up_${formation_position_rule_num};
            return ${unit.id}_ss_pantographs_down_${formation_position_rule_num};
        }
        <!--! some vehicle models don't show pans if the OpenTTD consist is not powered
              this isn't very sophisticated as of Feb 2024, it literally just checks if engine (cab cars) are in the conist, doesn't check for contiguous chain -->
        switch (FEAT_TRAINS, PARENT, ${unit.id}_switch_graphics_pantographs_${formation_position_rule_num},
            [
                <!--! OR because if the consist doesn't use the suppression flag, we always show pans -->
                ${int(not model_variant.suppress_pantograph_if_no_engine_attached)}
                <tal:has_cab_consist condition="catalogue.cab_engine_model is not None">
                    ||
                    count_has_badge("ih_pantograph_display/is_cab/${catalogue.cab_engine_model.model_id}") > 0

                </tal:has_cab_consist>

            ]
        ) {
            1: return ${unit.id}_switch_graphics_pantographs_state_${formation_position_rule_num};
            return ss_global_empty_vehicle;
        }
    </tal:pantographs>
</tal:formation_position_rules>

<!--! stupid integer stuffing scheme to detect livery / flip / doors states, see the procedures for the schema
      this does *not* try to handle variant ID in the same switch - that approach was removed as it caused concurrent varact2 IDs to be exhausted with higher numbers of variants -->
switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_vehicle_check_engine_and_doors,
        [
            (10 * LOAD_TEMP(${temp_storage_map.formation_position_rule_num}))
            +
            (1 * alt_var_loaded_loading_state_opening_doors())
        ]
    ) {
    <tal:formation_position_rules repeat="formation_position_rule_num python:range(model_variant.gestalt_graphics.num_unique_formation_positions)">
        ${formation_position_rule_num}0: return ${unit.id}_ss_doors_closed_formation_position_rule_${formation_position_rule_num};
        ${formation_position_rule_num}1: return ${unit.id}_ss_doors_open_formation_position_rule_${formation_position_rule_num};
    </tal:formation_position_rules>
}

<tal:formation_position_rules repeat="formation_position_rule_num python:range(model_variant.gestalt_graphics.num_unique_formation_positions)">
    switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_vehicle_layers_${formation_position_rule_num},
            [
                STORE_TEMP(${formation_position_rule_num}, ${temp_storage_map.formation_position_rule_num}),
                getbits(extra_callback_info1, 8, 8)
            ]
        ){
        0: return ${unit.id}_switch_graphics_vehicle_check_engine_and_doors;
        <tal:conditional_pantograph condition="model_variant.pantograph_type is not None">
            <!--! if there are pantographs to draw we will handle that later in the graphics chain,
                  but we need to reserve layer 1 for the pantographs as well as layer 0 for the vehicle  -->
            1: return ${unit.id}_switch_graphics_pantographs_${formation_position_rule_num};
        </tal:conditional_pantograph>
    }

</tal:formation_position_rules>

<tal:vars define="formation_position_labels model_variant.gestalt_graphics.formation_position_spriterow_map">
    <tal:switch_position_ruleset switch="model_variant.gestalt_graphics.formation_ruleset">
        <!--! rulesets must comply with the position names in gestalt_graphics
              these could be extended or made arbitrary, but that's unwanted complexity -->
        <tal:position_ruleset case="'pax_cars'">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, switch_graphics_pax_car_ruleset()) {
                0: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['default']};
                1: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['first']};
                2: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['last']};
                3: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['special']};
            }
        </tal:position_ruleset>

        <tal:position_ruleset case="'mail_cars'">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, switch_graphics_mail_car_ruleset()) {
                0: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['default']};
                1: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['first']};
                2: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['last']};
                3: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['special']};
            }
        </tal:position_ruleset>

        <tal:position_ruleset case="'railcars_6_unit_sets'">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, switch_graphics_railcar_ruleset_6_unit_sets()) {
                0: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['default']};
                1: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['first']};
                2: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['last']};
                3: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['special']};
            }
        </tal:position_ruleset>

        <tal:position_ruleset case="'railcars_4_unit_sets'">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, switch_graphics_railcar_ruleset_4_unit_sets()) {
                0: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['default']};
                1: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['first']};
                2: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['last']};
                3: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['special']};
            }
        </tal:position_ruleset>

        <tal:position_ruleset case="'railcars_3_unit_sets'">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, switch_graphics_railcar_ruleset_3_unit_sets()) {
                0: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['default']};
                1: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['first']};
                2: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['last']};
                3: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['special']};
            }
        </tal:position_ruleset>

        <tal:position_ruleset case="'railcars_2_unit_sets'">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, switch_graphics_railcar_ruleset_2_unit_sets()) {
                0: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['default']};
                1: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['first']};
                2: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['last']};
            }
        </tal:position_ruleset>

        <tal:position_ruleset case="'tgv_hst'">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, switch_graphics_tgv_hst_ruleset()) {
                0: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['default']};
                1: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['first']};
                2: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['last']};
                3: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['special']};
            }
        </tal:position_ruleset>

        <tal:position_ruleset case="'driving_cab_cars'">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, switch_graphics_driving_cab_car_ruleset()) {
                0: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['default']};
                1: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['last']};
            }
        </tal:position_ruleset>

        <tal:position_ruleset case="'metro'">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, switch_graphics_metro_ruleset()) {
                0: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['first']};
                1: return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['last']};
            }
        </tal:position_ruleset>

        <tal:position_ruleset case="None">
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_position_in_formation_entry_point, 0) {
                return ${unit.id}_switch_graphics_vehicle_layers_${formation_position_labels['special']};
            }
        </tal:position_ruleset>
    </tal:switch_position_ruleset>
</tal:vars>

<!--! (conditional) stuff any temp storages needed for use with the var_41_but_badges_not_ids magic -->
switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_vehicle,
    <tal:fill_temp_storage condition="catalogue.formation_ruleset_equivalence_badge is not None">initialise_alt_var_41_with_badge_predicate(badgetype("ih_formation_ruleset/vehicle_reports_as/${model_variant.gestalt_graphics.formation_ruleset_target_reporting_label}"))</tal:fill_temp_storage>
    <tal:no_fill_temp_storage condition="catalogue.formation_ruleset_equivalence_badge is None">1</tal:no_fill_temp_storage>
    ) {
    return ${unit.id}_switch_graphics_position_in_formation_entry_point;
}

<tal:buy_menu_lead_unit_only condition="unit.is_not_trailing_part">
    spriteset(${unit.id}_ss_vehicle_purchase, "${graphics_path}${model_variant.model_id}.png") {
        <!--! note the weird jank to handle articulated the y position of buy menu sprites
              it's easier for the buy menu sprite generator to place them where it places them, then deal with it here -->
        <tal:buy_menu_sprite_switch_case switch="model_variant.requires_custom_buy_menu_sprite">
            <tal:case case="True">
                <!--! custom buy menu sprites are generated in the order required for the variants in buy menu, and are in consecutive spriterows -->
                ${model_variant.get_nml_for_spriteset_template(y_offset=catalogue_entry.index * 30)}
            </tal:case>
            <tal:case case="False">
                <!--! non-custom buy menu sprites use a specific relative_spriterow_num and need to skip a row to account for door states -->
                ${model_variant.get_nml_for_spriteset_template(y_offset=model_variant.catalogue_entry.livery_def.relative_spriterow_num * 60)}
            </tal:case>
        </tal:buy_menu_sprite_switch_case>
    }

    switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_vehicle_purchase, vehicle_type_id) {
        ${unit.numeric_id}: return ${unit.id}_ss_vehicle_purchase;
        <!--! no default, by design all variants should be explicitly found -->
    }
    <tal:conditional_pantographs switch="(model_variant.pantograph_type is not None) and (not model_variant.suppress_pantograph_if_no_engine_attached)">
        <tal:has_pantographs case="True">
            <!--! purchase sprites for case where pantograph layer is needed -->
            spriteset(${unit.id}_ss_pantograph_purchase, "${graphics_path}${model_variant.model_id}_pantographs_down.png") {
                ${model_variant.get_nml_for_spriteset_template(y_offset=0)}
            }
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_set_layers_register_more_sprites_purchase, STORE_TEMP(CB_FLAG_MORE_SPRITES | PALETTE_USE_DEFAULT, 0x100)) {
                return ${unit.id}_switch_graphics_vehicle_purchase;
            }
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_purchase, getbits(extra_callback_info1, 8, 8)) {
                <!--! if there are pantographs to draw we will handle that later in the graphics chain,
                      but we need to reserve layer 1 for the pantographs as well as layer 0 for the vehicle  -->
                0: return ${unit.id}_switch_set_layers_register_more_sprites_purchase;
                1: return ${unit.id}_ss_pantograph_purchase;
            }
        </tal:has_pantographs>
        <tal:no_pantographs case="False">
            <!--! purchase sprites always go through a switch in case the template does anything specific for purchase graphics
                  when there is nothing specific, then this is just a null switch -->
            switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_purchase, 0) {
                0: return ${unit.id}_switch_graphics_vehicle_purchase;
            }
        </tal:no_pantographs>
    </tal:conditional_pantographs>
</tal:buy_menu_lead_unit_only>


<!--!
    dedicated colour remapping for CC, as defined by the livery, no flip support
-->
switch (FEAT_TRAINS, SELF, ${unit.id}_switch_colour_mapping, vehicle_type_id) {
    <tal:forced_remap switch="model_variant.catalogue_entry.livery_def.remap_to_cc is not None">
        <tal:remap case="True">
            ${unit.numeric_id}: return base_sprite_2cc + 16 * ${model_variant.catalogue_entry.livery_def.remap_to_cc['company_colour2']} + ${model_variant.catalogue_entry.livery_def.remap_to_cc['company_colour1']};
        </tal:remap>
        <tal:no_remap case="False">
            ${unit.numeric_id}:return base_sprite_2cc + 16 * company_colour2 + company_colour1; <!--! apply regular 1CC and 2CC -->
        </tal:no_remap>
    </tal:forced_remap>
}


