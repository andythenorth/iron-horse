<!--! ** Various strategies for random recolouring of vehicles / intermodal containers ** -->

<!--! partial 2cc support was removed here Sept 2024, as not used -->
<tal:colour_sets repeat="colour_set global_constants.colour_sets.items()">
    <!--! note that random bits need to be unique within the switch chain to prevent dependent results -->
    <!--! uses 1 random bit from self, just 2 colour choices, more is overkill and often looks bad -->
    switch (FEAT_TRAINS, SELF, switch_colour_set_${colour_set[0]}_1cc,
                <!--! check if randomisation is enabled (player parameter) -->
                <!--! note that this relies on purchase context having no random bits, to avoid applying weathering to purchase sprite...probably fine? -->
                param_wagon_colour_randomisation && has_badge("ih_livery_def/use_weathering/True")
                ? random_bits_colour_set()
                : 0) {
        1: return ${utils.unpack_colour(colour_set[1][1], 1)};
        return ${utils.unpack_colour(colour_set[1][0], 1)};
    }
</tal:colour_sets>

switch(FEAT_TRAINS, SELF, switch_get_complement_to_company_colour, company_colour1) {
    <tal:complements_to_company_colours repeat="complement_pair global_constants.complements_to_company_colours.items()">
        ${complement_pair[0]}: return ${complement_pair[1]};
    </tal:complements_to_company_colours>
}

<!--! * Strategies for random recolouring of freight wagons * -->

<tal:livery_loop_unroll repeat="livery livery_supplier.freight_wagon_liveries.values()">
    switch(FEAT_TRAINS, SELF, switch_freight_wagon_get_livery_num_from_badge_${repeat.livery.index}, has_badge("${livery.badge_label}")) {
        1: return ${repeat.livery.index};
        <tal:block switch="repeat.livery.start">
            <tal:continue_loop case="False">
                return switch_freight_wagon_get_livery_num_from_badge_${repeat.livery.index - 1};
            </tal:continue_loop>
            <tal:end_loop case="True">
                <!--! should never be reached, not going to worry too much about that unless it shows up -->
                return -1;
            </tal:end_loop>
        </tal:block>
    }
</tal:livery_loop_unroll>
switch(FEAT_TRAINS, SELF, switch_freight_wagon_get_livery_num_from_badge,
        switch_freight_wagon_get_livery_num_from_badge_${len(livery_supplier.freight_wagon_liveries) - 1}()
    ) {
    return;
}
<!--! up to 8 random liveries (all 8 must be passed as params when initing the wagon chain -->
switch(FEAT_TRAINS, SELF, switch_freight_wagon_get_random_livery_from_candidates, random_bits_wagon_random_remap_livery()) {
     <tal:available_liveries repeat="livery_num range(8)">
         ${livery_num}: return LOAD_TEMP(${temp_storage_map.get("wagon_recolour_livery_num_" + str(livery_num))});
     </tal:available_liveries>
}

<!--! convenience switch to define how to pick a colour -->
switch(FEAT_TRAINS, SELF, switch_freight_wagon_livery_get_colour_set_index, switch_freight_wagon_get_random_livery_from_candidates()) {
    <!--! special cases for liveries using company colour,
          we'll need to remap the randomly selected livery index to an index based on current company colour in game -->
    100: return company_colour1;
    101: return switch_get_complement_to_company_colour();
    return; <!--! by default just return the randomly selected livery index -->
}

<!--! * Strategies for random recolouring of wagons *
    1. strategies branch (on livery badge) to one or more colour sets determined by the livery
    2. colour set is chosen at random (if there is more than one colour set in the list, otherwise single colour set is returned)
    3. colour sets apply a random choice from 2 shades of the chosen colour
-->

switch (FEAT_TRAINS, SELF, switch_freight_wagon_livery_select_colour_set,
                    switch_freight_wagon_livery_get_colour_set_index()
                ) {
    <tal:colour_sets repeat="colour_set global_constants.colour_sets.items()">
        <!--! this relies on order matching the order of company colours per nml / openttd constants;
              e.g. COLOUR_DARK_BLUE = 0, COLOUR_WHITE= 15
              we then extend our own custom colour sets after the default colours -->
        <!--! // debug: ${colour_set[1][0]}, ${colour_set[1][1]} -->
        ${repeat.colour_set.index}: switch_colour_set_${colour_set[0]}_1cc;
    </tal:colour_sets>
}

switch (FEAT_TRAINS, SELF, switch_freight_wagon_livery_set_params,
        flag_context_is_purchase,
        <tal:available_liveries repeat="livery_num range(8)">
            wagon_recolour_livery_num_${livery_num},
        </tal:available_liveries>
                [
                 STORE_TEMP(flag_context_is_purchase, ${temp_storage_map.flag_context_is_purchase}),
                 <tal:available_liveries repeat="livery_num range(8)">
                     STORE_TEMP(wagon_recolour_livery_num_${livery_num}, ${temp_storage_map.get("wagon_recolour_livery_num_" + str(livery_num))}),
                 </tal:available_liveries>
                ]) {
    switch_freight_wagon_livery_select_colour_set;
}

<!--! switch as lookup table for combinations of colour set params, this is the most effective way I found to extract the livery params for use in switches -->
switch(FEAT_TRAINS, SELF, switch_freight_wagon_livery_serialised_liveries, livery_num_offset, livery_num_offset + switch_freight_wagon_get_livery_num_from_badge()) {
    <tal:wagon_recolour_set repeat="livery_serialized livery_supplier.freight_wagon_livery_serialized_params">
        ${livery_serialized.livery_index}: return switch_freight_wagon_livery_set_params(${livery_serialized.serialized_params}); // ${livery_serialized.livery_name}
    </tal:wagon_recolour_set>
}

switch(FEAT_TRAINS, SELF, switch_freight_wagon_livery_entry_point,
        <!--! the 0 here is an offset which can be used to access purchase liveries, but in this non-purchase case offset is 0 -->
        switch_freight_wagon_livery_serialised_liveries(0)
    ) {
    return;
}
switch(FEAT_TRAINS, SELF, switch_freight_wagon_livery_entry_point_purchase,
        <!--! for purchase we offset into a second block of serialised liveries which will have different flags set -->
        switch_freight_wagon_livery_serialised_liveries(${len(livery_supplier.freight_wagon_liveries)})
    ) {
    return;
}

<!--! * Strategies for random recolouring of intermodal containers * -->

<!--!  these are rudimentary in that
       1. they won't recolour within the container group, only between wagons
       2. only 1cc is recoloured due to combinatorial explosion if both 1cc and 2cc are randomised in recolour sprites (those sprites _could_ be generated though)
       3. I didn't check if the random bits used to choose colour set collide with any other uses
       4. this works for train wagons, wouldn't work for ships as individual containers can't be controlled
-->

<!--! partial 2cc support was removed here Sept 2024, as not used -->

<!--!! possibly it would be better better to
     - generate box containers for all the CC variants directly in Polar Fox, including the alternative shade for every company colour
     - then compose those into fixed container groups in Iron Horse (cc1_alt etc), so each group produces 16 colour variants
     - then switch the final sprites on the company current colour
     - seems like work, but it's what ships will probably need to do?
     - would non-trivially complicate generating intermodal container spritesets etc
     - also would remove randomisation from non-box containers
     - so basically, unappealing-->
switch (FEAT_TRAINS, SELF, switch_intermodal_container_by_company_colour_1cc_to_1cc, company_colour1) {
    COLOUR_DARK_BLUE: switch_colour_set_dark_blue_1cc;
    COLOUR_PALE_GREEN: switch_colour_set_pale_green_1cc;
    COLOUR_PINK: switch_colour_set_pink_1cc;
    COLOUR_YELLOW: switch_colour_set_yellow_1cc;
    COLOUR_RED: switch_colour_set_red_1cc;
    COLOUR_LIGHT_BLUE: switch_colour_set_light_blue_1cc;
    COLOUR_GREEN: switch_colour_set_green_1cc;
    COLOUR_DARK_GREEN: switch_colour_set_dark_green_1cc;
    COLOUR_BLUE: switch_colour_set_blue_1cc;
    COLOUR_CREAM: switch_colour_set_cream_1cc;
    COLOUR_MAUVE: switch_colour_set_mauve_1cc;
    COLOUR_PURPLE: switch_colour_set_purple_1cc;
    COLOUR_ORANGE: switch_colour_set_orange_1cc;
    COLOUR_BROWN: switch_colour_set_brown_1cc;
    COLOUR_GREY: switch_colour_set_grey_1cc;
    COLOUR_WHITE: switch_colour_set_white_1cc;
}
