<tal:ruleset define="first 0; last 1;">
    // automobile transporter articulated permanent twin set (no default single unit required)
    <!--! first / last; NOTE use of position_in_articulated_veh not position_in_vehid_chain -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_articulated_permanent_twin_sets, position_in_articulated_veh % 2) {
        0: return ${first};
        return ${last};
    }
</tal:ruleset>


<tal:ruleset define="default 0;">
    // automobile transporter 1 unit position switches
    <!--!
        if 1 unit in sequence
        - note that this just yields a constant result and will likely be optimised out by nmlc but eh, consistency with other switches for now
    -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_1_unit_sets, 0) {
        0: return ${default};
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2;">
    // automobile transporter 2 unit position switches
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_2_unit_sets_modulo_num_units_in_consist_1, position_in_vehid_chain % 2) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_2_unit_sets_modulo_num_units_in_consist_2, position_in_vehid_chain % 2) {
        0: return ${first};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_2_unit_sets_less_than_2_remaining, num_vehs_in_vehid_chain % 2) {
        1: return switch_graphics_automobile_transporter_ruleset_2_unit_sets_modulo_num_units_in_consist_1;
        return switch_graphics_automobile_transporter_ruleset_2_unit_sets_modulo_num_units_in_consist_2;
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_2_unit_sets, position_in_vehid_chain >= (num_vehs_in_vehid_chain - (num_vehs_in_vehid_chain  % 2))) {
        1: return switch_graphics_automobile_transporter_ruleset_2_unit_sets_less_than_2_remaining;
        return switch_graphics_automobile_transporter_ruleset_2_unit_sets_modulo_num_units_in_consist_2;
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2; middle 3;">
    // automobile transporter 4 unit position switches
    <!--! if 1 unit in sequence -->
    <!--! 0 = first, 1 = middle, 2 = last -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_1, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_2, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_3, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${middle};
        return ${last};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_4, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${middle};
        return ${last};
    }

    <!--! if 5 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_5, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${last};
        3: ${first};
        return ${last};
    }

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_6, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${last};
        3: ${first};
        4: ${middle};
        return ${last};
    }

    <!--! if 7 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_7, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${middle};
        3: ${last};
        4: ${first};
        5: ${middle};
        return ${last};
    }

    <!--! if 7 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_8, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${middle};
        3: ${last};
        4: ${first};
        5: ${middle};
        6: ${middle};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_check_remainder_block_length, [
            (num_vehs_in_vehid_chain - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset})) % 8
        ]) {
        1: return switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_1;
        2: return switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_2;
        3: return switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_3;
        4: return switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_4;
        5: return switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_5;
        6: return switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_6;
        7: return switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_7;
        return switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 4, just modulo 8 will get the result we need
              we use 8 rather than 4 to allow special handling of special sprites (if needed) alternate blocks of 4, in A, B, A, B type pattern -->
            STORE_TEMP(
                position_in_vehid_chain % 8,
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_automobile_transporter_ruleset_4_unit_sets_modulo_num_units_in_consist_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                position_in_vehid_chain - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}),
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_automobile_transporter_ruleset_4_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 4 units are there?  Is the unit within a block of 4, or a remainder block?
          we actually control positions out to 8 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_automobile_transporter_ruleset_4_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 4 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 4 (divisor = 4)
                          - a remainder amount which is at least 4 (and won't be more than 8), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    num_vehs_in_vehid_chain > 4
                        ?
                        4 * ((num_vehs_in_vehid_chain / 4) - 1)
                        :
                        0,
                    ${temp_storage_ids.position_in_vehid_chain_base_offset}
                ),
                (position_in_vehid_chain >= LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}))
            ]) {
        1: return switch_graphics_automobile_transporter_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position;
        return switch_graphics_automobile_transporter_ruleset_4_unit_sets_whole_divisor_block;
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2;">
    // intermodal platform 2 unit position switches
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_2_unit_sets_modulo_num_units_in_consist_1, position_in_vehid_chain % 2) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_2_unit_sets_modulo_num_units_in_consist_2, position_in_vehid_chain % 2) {
        0: return ${first};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_2_unit_sets_less_than_2_remaining, num_vehs_in_vehid_chain % 2) {
        1: return switch_graphics_intermodal_platform_ruleset_2_unit_sets_modulo_num_units_in_consist_1;
        return switch_graphics_intermodal_platform_ruleset_2_unit_sets_modulo_num_units_in_consist_2;
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_2_unit_sets, position_in_vehid_chain >= (num_vehs_in_vehid_chain - (num_vehs_in_vehid_chain  % 2))) {
        1: return switch_graphics_intermodal_platform_ruleset_2_unit_sets_less_than_2_remaining;
        return switch_graphics_intermodal_platform_ruleset_2_unit_sets_modulo_num_units_in_consist_2;
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2; middle 3;">
    // intermodal platform 4 unit position switches
    <!--! if 1 unit in sequence -->
    <!--! 0 = first, 1 = middle, 2 = last -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_1, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_2, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_3, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${middle};
        return ${last};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_4, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${middle};
        return ${last};
    }

    <!--! if 5 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_5, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${last};
        3: ${first};
        return ${last};
    }

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_6, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${last};
        3: ${first};
        4: ${middle};
        return ${last};
    }

    <!--! if 7 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_7, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${middle};
        3: ${last};
        4: ${first};
        5: ${middle};
        return ${last};
    }

    <!--! if 7 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_8, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: ${first};
        1: ${middle};
        2: ${middle};
        3: ${last};
        4: ${first};
        5: ${middle};
        6: ${middle};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_check_remainder_block_length, [
            (num_vehs_in_vehid_chain - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset})) % 8
        ]) {
        1: return switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_1;
        2: return switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_2;
        3: return switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_3;
        4: return switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_4;
        5: return switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_5;
        6: return switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_6;
        7: return switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_7;
        return switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 4, just modulo 8 will get the result we need
              we use 8 rather than 4 to allow special handling of special sprites (if needed) alternate blocks of 4, in A, B, A, B type pattern -->
            STORE_TEMP(
                position_in_vehid_chain % 8,
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_intermodal_platform_ruleset_4_unit_sets_modulo_num_units_in_consist_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                position_in_vehid_chain - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}),
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_intermodal_platform_ruleset_4_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 4 units are there?  Is the unit within a block of 4, or a remainder block?
          we actually control positions out to 8 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_intermodal_platform_ruleset_4_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 4 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 4 (divisor = 4)
                          - a remainder amount which is at least 4 (and won't be more than 8), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    num_vehs_in_vehid_chain > 4
                        ?
                        4 * ((num_vehs_in_vehid_chain / 4) - 1)
                        :
                        0,
                    ${temp_storage_ids.position_in_vehid_chain_base_offset}
                ),
                (position_in_vehid_chain >= LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}))
            ]) {
        1: return switch_graphics_intermodal_platform_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position;
        return switch_graphics_intermodal_platform_ruleset_4_unit_sets_whole_divisor_block;
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2; special 3;">
    // pax coach position switches
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_default, 0) {
        return ${default};
    }

    <!--! if special -->
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_special_check_length, num_vehs_in_vehid_chain) {
        <!--! don't show 'special' if same id chain < 4 vehicles -->
        0..3: return switch_graphics_pax_car_ruleset_position_default;
        return ${special};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_special, position_in_vehid_chain_from_end - position_in_vehid_chain) {
        0..1: return switch_graphics_pax_car_ruleset_position_special_check_length;
        switch_graphics_pax_car_ruleset_position_default;
    }

    <!--! if last -->
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_last_neighbouring, [STORE_TEMP(badgetype("ih_ruleset_flags/report_as_pax_car"), 0x10E), STORE_TEMP(1, 0x10F), var[0x61, 0, 0x00000001, 0x7A]]) {
        <!--! don't show last if following vehicle is also a valid pax car -->
        1: return ${default};
        return ${last};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_last, position_in_vehid_chain_from_end) {
        0: switch_graphics_pax_car_ruleset_position_check_last_neighbouring;
        switch_graphics_pax_car_ruleset_position_check_special;
    }

    <!--! if first -->
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_first_neighbouring, [STORE_TEMP(badgetype("ih_ruleset_flags/report_as_pax_car"), 0x10E), STORE_TEMP(-1, 0x10F), var[0x61, 0, 0x00000001, 0x7A]]) {
        <!--! don't show first if preceeding vehicle is also a valid pax car -->
        1: return ${default};
        return ${first};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_first_check_length, num_vehs_in_vehid_chain) {
        <!--! don't show 'first' if same id chain < 5 vehicles -->
        0..4: return switch_graphics_pax_car_ruleset_position_default;
        return switch_graphics_pax_car_ruleset_position_check_first_neighbouring;
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_first, position_in_vehid_chain) {
        0: return switch_graphics_pax_car_ruleset_position_first_check_length;
        switch_graphics_pax_car_ruleset_position_check_last;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset, num_vehs_in_vehid_chain) {
        <!--! always show default if same id chain < 2 vehicles -->
        0..1: return switch_graphics_pax_car_ruleset_position_default;
        return switch_graphics_pax_car_ruleset_position_check_first;
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2; special 3;">
    // mail car position switches
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_default, 0) {
        return ${default};
    }

    <!--! if special -->
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_special_check_length, num_vehs_in_vehid_chain) {
        <!--! don't show 'special' if same id chain < 4 vehicles -->
        0..3: return switch_graphics_mail_car_ruleset_position_default;
        return ${special};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_special, position_in_vehid_chain_from_end - position_in_vehid_chain) {
        0..1: return switch_graphics_mail_car_ruleset_position_special_check_length;
        switch_graphics_mail_car_ruleset_position_default;
    }

    <!--! if first -->
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_first_neighbouring, [STORE_TEMP(badgetype("ih_ruleset_flags/report_as_mail_car"), 0x10E), STORE_TEMP(-1, 0x10F), var[0x61, 0, 0x00000001, 0x7A]]) {
        <!--! don't show first if preceeding vehicle is also a valid pax car -->
        1: return ${default};
        return ${first};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_first_check_length, num_vehs_in_vehid_chain) {
        <!--! don't show 'first' if same id chain < 5 vehicles -->
        0..4: return switch_graphics_mail_car_ruleset_position_default;
        return switch_graphics_mail_car_ruleset_position_check_first_neighbouring;
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_first, position_in_vehid_chain) {
        0: return switch_graphics_mail_car_ruleset_position_first_check_length;
        switch_graphics_mail_car_ruleset_position_check_special;
    }

    <!--! if last -->
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_last_neighbouring, [STORE_TEMP(badgetype("ih_ruleset_flags/report_as_mail_car"), 0x10E), STORE_TEMP(1, 0x10F), var[0x61, 0, 0x00000001, 0x7A]]) {
        <!--! don't show last if following vehicle is also a valid pax car -->
        1: return ${default};
        return ${last};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_last, position_in_vehid_chain_from_end) {
        0: switch_graphics_mail_car_ruleset_position_check_last_neighbouring;
        switch_graphics_mail_car_ruleset_position_check_first;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset, 0) {
        return switch_graphics_mail_car_ruleset_position_check_last;
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2; special 3;">
    // railcar 6 unit position switches
    <!--! there is never 1 unit for this ruleset, always minimum 2 -->

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_2, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        return ${last};
    }

    <!--! there are never 3 units for this ruleset, always multiple of 2 -->

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_4, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        return ${last};
    }

    <!--! there are never 5 units for this ruleset, always multiple of 2 -->

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_6, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${default};
        3: return ${special};
        4: return ${default};
        return ${last};
    }

    <!--! there are never 7 units for this ruleset, always multiple of 2 -->

    <!--! if 8 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_8, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        3: return ${last};
        4: return ${first};
        5: return ${default};
        6: return ${default};
        return ${last};
    }

    <!--! there are never 9 units for this ruleset, always multiple of 2 -->

    <!--! if 10 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_10, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        3: return ${default};
        4: return ${last};
        5: return ${first};
        6: return ${default};
        7: return ${default};
        8: return ${default};
        return ${last};
    }

    <!--! there are never 11 units for this ruleset, always multiple of 2 -->

    <!--! if 12 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_12, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        3: return ${default};
        4: return ${default};
        5: return ${last};
        6: return ${first};
        7: return ${default};
        8: return ${default};
        9: return ${special};
        10: return ${default};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_length,
            (LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset})) % 12
        ) {
        <!--! there is never 1 unit for this ruleset, always minimum 2 -->
        2: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_2;
        <!--! there are never 3 units for this ruleset, always multiple of 2 -->
        4: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_4;
        <!--! there are never 5 units for this ruleset, always multiple of 2 -->
        6: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_6;
        <!--! there are never 7 units for this ruleset, always multiple of 2 -->
        8: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_8;
        <!--! there are never 9 units for this ruleset, always multiple of 2 -->
        10: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_10;
        <!--! there are never 11 units for this ruleset, always multiple of 2 -->
        return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_12;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 6, just modulo 12 will get the result we need
              we use 12 rather than 6 to allow special handling of e.g. restaurant car position in alternate blocks of 6, in A, B, A, B type pattern
              - and also precise control over remainder block arrangement (e.g. block of 5 as 2 + 3 or similar)
            -->
            STORE_TEMP(
                LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) % 12,
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_consist_12;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}),
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 6 units are there?  Is the unit within a block of 6, or a remainder block?
          we actually control positions out to 12 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 6 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 6 (divisor = 6)
                          - a remainder amount which is at least 6 (and won't be more than 12), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) > 6
                        ?
                        6 * ((LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) / 6) - 1)
                        :
                        0,
                    ${temp_storage_ids.position_in_vehid_chain_base_offset}
                ),
                (LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) > LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}))
            ]) {
        1: return switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_apply_base_offset_to_position;
        return switch_graphics_railcar_ruleset_6_unit_sets_whole_divisor_block;
    }

</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2; special 3;">
    // railcar 4 unit position switches
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_1, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_2, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_3, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        return ${last};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_4, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${special};
        return ${last};
    }

    <!--! if 5 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_5, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        return ${last};
    }

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_6, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        4: return ${special};
        return ${last};
    }

    <!--! if 7 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_7, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${special};
        3: return ${last};
        4: return ${first};
        5: return ${special};
        return ${last};
    }

    <!--! if 8 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_8, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${special};
        3: return ${last};
        4: return ${first};
        5: return ${special};
        6: return ${special};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_length,
            (LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset})) % 8
        ) {
        1: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_1;
        2: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_2;
        3: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_3;
        4: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_4;
        5: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_5;
        6: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_6;
        7: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_7;
        return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 4, just modulo 8 will get the result we need
              we use 8 rather than 4 to allow optional special handling of e.g. 'special' car positions in alternate blocks of 4, in A, B, A, B type pattern
              - !! that might actually be moot for 4-unit sets, where 'special' is the single unit cab car
        -->
            STORE_TEMP(
                LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) % 8,
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_consist_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}),
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 4 units are there?  Is the unit within a block of 4, or a remainder block?
          we actually control positions out to 8 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 4 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 4 (divisor = 4)
                          - a remainder amount which is at least 4 (and won't be more than 8), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) > 4
                        ?
                        4 * ((LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) / 4) - 1)
                        :
                        0,
                    ${temp_storage_ids.position_in_vehid_chain_base_offset}
                ),
                (LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) >= LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}))
            ]) {
        1: return switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position;
        return switch_graphics_railcar_ruleset_4_unit_sets_whole_divisor_block;
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2; special 3;">
    // railcar 3 unit position switches
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_1, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_2, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_3, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        return ${last};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_4, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${last};
        2: return ${first};
        return ${last};
    }

    <!--! if 5 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_5, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        return ${last};
    }

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_6, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        4: return ${special};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_length,
            (LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset})) % 6
        ) {
        1: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_1;
        2: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_2;
        3: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_3;
        4: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_4;
        5: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_5;
        return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_6;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 3, just modulo 6 will get the result we need
              we use 6 rather than 3 to allow optional special handling of e.g. 'special' car positions in alternate blocks of 6, in A, B, A, B type pattern
              - and also precise control over remainder block arrangement (e.g. block of 5 as 2 + 3 or similar)
        -->
            STORE_TEMP(
                LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) % 6,
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_6;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}),
                ${temp_storage_ids.position_in_vehid_chain_multiple_ids_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 3 units are there?  Is the unit within a block of 4, or a remainder block?
          we actually control positions out to 6 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 3 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 3 (divisor = 3)
                          - a remainder amount which is at least 3 (and won't be more than 6), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) > 3
                        ?
                        3 * ((LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) / 3) - 1)
                        :
                        0,
                    ${temp_storage_ids.position_in_vehid_chain_base_offset}
                ),
                (LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) >= LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_base_offset}))
            ]) {
        1: return switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_apply_base_offset_to_position;
        return switch_graphics_railcar_ruleset_3_unit_sets_whole_divisor_block;
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2;">
    // railcar 2 unit position switches
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_consist_1, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) % 4) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_consist_2, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) % 4) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_consist_3, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) % 4) {
        0: return ${first};
        1: return ${last};
        return ${default};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_consist_4, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) % 4) {
        0: return ${first};
        1: return ${last};
        2: return ${first};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_less_than_4_remaining, LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) % 4) {
        1: return switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_consist_1;
        2: return switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_consist_2;
        3: return switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_consist_3;
        return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_consist_4;
    }

    <!--! given the consist, how many blocks of 4 units are there?  Is the unit within a block of 4, or a remainder block? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids}) >= (LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) - (LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids}) % 4))) {
        1: return switch_graphics_railcar_ruleset_2_unit_sets_less_than_4_remaining;
        return switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_consist_4;
    }
</tal:ruleset>

<tal:ruleset define="default 0; first 1; last 2; special 3;">
    // pax coach position switches
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_ruleset_position_default, 0) {
        return ${default};
    }

    <!--! if special -->
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_ruleset_position_special_check_length, LOAD_TEMP(${temp_storage_ids.num_vehs_in_vehid_chain_multiple_ids})) {
        <!--! don't show 'special' if equivalent id chain < 4 vehicles -->
        0..3: return switch_graphics_tgv_ruleset_position_default;
        return ${special};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_ruleset_position_check_special, [
                LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_from_end_multiple_ids}) - LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids})
            ]
        ) {
        0..1: return switch_graphics_tgv_ruleset_position_special_check_length;
        switch_graphics_tgv_ruleset_position_default;
    }

    <!--! if last -->
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_ruleset_position_check_last, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_from_end_multiple_ids})) {
        0: return ${last};
        switch_graphics_tgv_ruleset_position_check_special;
    }
    <!--! if first -->
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_ruleset, LOAD_TEMP(${temp_storage_ids.position_in_vehid_chain_multiple_ids})) {
        <!--! TGV cars always show first if at start of equivalent id chain -->
        0: return ${first};
        switch_graphics_tgv_ruleset_position_check_last;
    }
</tal:ruleset>

<tal:ruleset define="default 0; last 1;">
    // driving cab position switches
    <!--! only show 'last' if consist has > 1 vehicle - keeps the cab orientated <- when built in depot, matching buy menu -->
    switch (FEAT_TRAINS, SELF, switch_graphics_driving_cab_car_ruleset_position_last_check_length, num_vehs_in_consist) {
        1: return ${default};
        return ${last};
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_driving_cab_car_ruleset, position_in_consist_from_end) {
        0: switch_graphics_driving_cab_car_ruleset_position_last_check_length;
        return ${default};
    }
</tal:ruleset>

<tal:ruleset define="first 0; last 1;">
    // metro position switches
    switch (FEAT_TRAINS, SELF, switch_graphics_metro_ruleset, position_in_vehid_chain % 2) {
        0: return ${first};
        return ${last};
    }
</tal:ruleset>

