<!--! set spawn model -->
<!--! assumes just 2 effects, default and electrified, deal with that later if it's a problem later
      if necessary, walk over the array of effects and check each track type explicitly
-->
<tal:spawn_model_varies_by_power_source switch="unit.effects_vary_by_power_source">
    <tal:effects_vary_by_power_source case="True">
        switch (FEAT_TRAINS, SELF, ${unit.id}_switch_effect_spawn_model_and_powered, ${model_variant.nml_expression_for_vehicle_is_electrically_powered_by_tile()}) {
            1: return ${unit.effects['electrified'][0]};
            return ${unit.effects['default'][0]};
        }
    </tal:effects_vary_by_power_source>
    <tal:default case="False">
        switch (FEAT_TRAINS, SELF, ${unit.id}_switch_effect_spawn_model_and_powered, 1) {
            return ${unit.effects['default'][0]};
        }
    </tal:default>
</tal:spawn_model_varies_by_power_source>

<!--! create effect -->
<!--! complicated due to support for railtype changes AND randomly reversed variants -->
<tal:railtypes repeat="railtype unit.effects">
    <tal:effect define="effects unit.get_nml_expression_for_effects(railtype)">
        switch (FEAT_TRAINS, SELF, ${unit.id}_switch_create_effect_${railtype}, ${effects[0]}) {
            return ${effects[1]};
        }
    </tal:effect>
</tal:railtypes>

<tal:effect_type_varies_by_power_source switch="unit.effects_vary_by_power_source">
    <tal:effects_vary_by_power_source case="True">
        switch (FEAT_TRAINS, SELF, ${unit.id}_switch_create_effect_check_railtype, ${model_variant.nml_expression_for_vehicle_is_electrically_powered_by_tile()}) {
            <!--! assumes just 2 effects, default and electrified, deal with that later if it's a problem later -->
            1: return ${unit.id}_switch_create_effect_electrified;
            return ${unit.id}_switch_create_effect_default;
        }
    </tal:effects_vary_by_power_source>
    <tal:default case="False">
        switch (FEAT_TRAINS, SELF, ${unit.id}_switch_create_effect_check_railtype, 1) {
            return ${unit.id}_switch_create_effect_default;
        }
    </tal:default
</tal:effect_type_varies_by_power_source>

<!--! is the vehicle powered at all?
    add more predicates here as needed - chain them from a tree if it gets combinatorial - but JFDI as of Jan 2026 -->
<tal:unit_has_any_power switch="model_variant.is_distributed_power_wagon and unit.is_not_trailing_part">
    <tal:is_distributed_power_wagon case="True">
        <!--! power varies if specific engines are present in the consist -->
        <!--! this is unsophisticated and doesn't bother enforcing that the cab unit must be contiguous with appropriate wagons -->
        switch (FEAT_TRAINS, PARENT, ${unit.id}_switch_create_effect_check_unit_has_any_power, count_has_badge("ih_distributed_power/is_power_cab/${catalogue.cab_engine_model.model_id}")) {
            0: return 0;
            return 1;
        }
    </tal:is_distributed_power_wagon>
    <tal:default case="False">
        switch (FEAT_TRAINS, SELF, ${unit.id}_switch_create_effect_check_unit_has_any_power, 1) {
            return 1;
        }
    </tal:default>
</tal:unit_has_any_power>

switch (FEAT_TRAINS, SELF, ${unit.id}_switch_create_effect, ${unit.id}_switch_create_effect_check_unit_has_any_power()) {
    1: return ${unit.id}_switch_create_effect_check_railtype;
    return VISUAL_EFFECT_DISABLE;
}
