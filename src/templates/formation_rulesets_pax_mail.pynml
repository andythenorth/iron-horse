<!--! position rulesets for formation-position-dependent vehicles -->

// pax car ruleset
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_default, 0) {
        return ${default};
    }

    <!--! if special -->
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_special_check_length, num_vehs_in_vehid_chain) {
        <!--! don't show 'special' if same id chain < 4 vehicles -->
        0..3: return switch_graphics_pax_car_ruleset_position_default;
        return ${special};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_special, position_in_vehid_chain_from_end - position_in_vehid_chain) {
        0..1: return switch_graphics_pax_car_ruleset_position_special_check_length;
        switch_graphics_pax_car_ruleset_position_default;
    }

    <!--! if last -->
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_last_neighbouring, [STORE_TEMP(badgetype("ih_formation_ruleset/vehicle_reports_as/generic_pax_car"), 0x10E), STORE_TEMP(1, 0x10F), var[0x61, 0, 0x00000001, 0x7A]]) {
        <!--! don't show last if following vehicle is also a valid pax car -->
        1: return ${default};
        return ${last};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_last, position_in_vehid_chain_from_end) {
        0: switch_graphics_pax_car_ruleset_position_check_last_neighbouring;
        switch_graphics_pax_car_ruleset_position_check_special;
    }

    <!--! if first -->
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_first_neighbouring, [STORE_TEMP(badgetype("ih_formation_ruleset/vehicle_reports_as/generic_pax_car"), 0x10E), STORE_TEMP(-1, 0x10F), var[0x61, 0, 0x00000001, 0x7A]]) {
        <!--! don't show first if preceeding vehicle is also a valid pax car -->
        1: return ${default};
        return ${first};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_first_check_length, num_vehs_in_vehid_chain) {
        <!--! don't show 'first' if same id chain < 5 vehicles -->
        0..4: return switch_graphics_pax_car_ruleset_position_default;
        return switch_graphics_pax_car_ruleset_position_check_first_neighbouring;
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_position_check_first, position_in_vehid_chain) {
        0: return switch_graphics_pax_car_ruleset_position_first_check_length;
        switch_graphics_pax_car_ruleset_position_check_last;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset, num_vehs_in_vehid_chain) {
        <!--! always show default if same id chain < 2 vehicles -->
        0..1: return switch_graphics_pax_car_ruleset_position_default;
        return switch_graphics_pax_car_ruleset_position_check_first;
    }
</tal:ruleset>


// mail car ruleset
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_default, 0) {
        return ${default};
    }

    <!--! if special -->
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_special_check_length, num_vehs_in_vehid_chain) {
        <!--! don't show 'special' if same id chain < 4 vehicles -->
        0..3: return switch_graphics_mail_car_ruleset_position_default;
        return ${special};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_special, position_in_vehid_chain_from_end - position_in_vehid_chain) {
        0..1: return switch_graphics_mail_car_ruleset_position_special_check_length;
        switch_graphics_mail_car_ruleset_position_default;
    }

    <!--! if first -->
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_first_neighbouring, [STORE_TEMP(badgetype("ih_formation_ruleset/vehicle_reports_as/generic_mail_car"), 0x10E), STORE_TEMP(-1, 0x10F), var[0x61, 0, 0x00000001, 0x7A]]) {
        <!--! don't show first if preceeding vehicle is also a valid pax car -->
        1: return ${default};
        return ${first};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_first_check_length, num_vehs_in_vehid_chain) {
        <!--! don't show 'first' if same id chain < 5 vehicles -->
        0..4: return switch_graphics_mail_car_ruleset_position_default;
        return switch_graphics_mail_car_ruleset_position_check_first_neighbouring;
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_first, position_in_vehid_chain) {
        0: return switch_graphics_mail_car_ruleset_position_first_check_length;
        switch_graphics_mail_car_ruleset_position_check_special;
    }

    <!--! if last -->
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_last_neighbouring, [STORE_TEMP(badgetype("ih_formation_ruleset/vehicle_reports_as/generic_mail_car"), 0x10E), STORE_TEMP(1, 0x10F), var[0x61, 0, 0x00000001, 0x7A]]) {
        <!--! don't show last if following vehicle is also a valid pax car -->
        1: return ${default};
        return ${last};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_position_check_last, position_in_vehid_chain_from_end) {
        0: switch_graphics_mail_car_ruleset_position_check_last_neighbouring;
        switch_graphics_mail_car_ruleset_position_check_first;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset, 0) {
        return switch_graphics_mail_car_ruleset_position_check_last;
    }
</tal:ruleset>


// railcar 6 unit sets
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    <!--! there is never 1 unit for this ruleset, always minimum 2 -->

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_2, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        return ${last};
    }

    <!--! there are never 3 units for this ruleset, always multiple of 2 -->

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_4, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        return ${last};
    }

    <!--! there are never 5 units for this ruleset, always multiple of 2 -->

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_6, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${default};
        3: return ${special};
        4: return ${default};
        return ${last};
    }

    <!--! there are never 7 units for this ruleset, always multiple of 2 -->

    <!--! if 8 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_8, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        3: return ${last};
        4: return ${first};
        5: return ${default};
        6: return ${default};
        return ${last};
    }

    <!--! there are never 9 units for this ruleset, always multiple of 2 -->

    <!--! if 10 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_10, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        3: return ${default};
        4: return ${last};
        5: return ${first};
        6: return ${default};
        7: return ${default};
        8: return ${default};
        return ${last};
    }

    <!--! there are never 11 units for this ruleset, always multiple of 2 -->

    <!--! if 12 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_12, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        3: return ${default};
        4: return ${default};
        5: return ${last};
        6: return ${first};
        7: return ${default};
        8: return ${default};
        9: return ${special};
        10: return ${default};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_length,
            (LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) - LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_base_offset})) % 12
        ) {
        <!--! there is never 1 unit for this ruleset, always minimum 2 -->
        2: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_2;
        <!--! there are never 3 units for this ruleset, always multiple of 2 -->
        4: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_4;
        <!--! there are never 5 units for this ruleset, always multiple of 2 -->
        6: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_6;
        <!--! there are never 7 units for this ruleset, always multiple of 2 -->
        8: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_8;
        <!--! there are never 9 units for this ruleset, always multiple of 2 -->
        10: return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_10;
        <!--! there are never 11 units for this ruleset, always multiple of 2 -->
        return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_12;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 6, just modulo 12 will get the result we need
              we use 12 rather than 6 to allow special handling of e.g. restaurant car position in alternate blocks of 6, in A, B, A, B type pattern
              - and also precise control over remainder block arrangement (e.g. block of 5 as 2 + 3 or similar)
            -->
            STORE_TEMP(
                LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) % 12,
                ${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_12;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) - LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_base_offset}),
                ${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 6 units are there?  Is the unit within a block of 6, or a remainder block?
          we actually control positions out to 12 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 6 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 6 (divisor = 6)
                          - a remainder amount which is at least 6 (and won't be more than 12), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) > 6
                        ?
                        6 * ((LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) / 6) - 1)
                        :
                        0,
                    ${temp_storage_ids.position_in_badge_predicate_chain_base_offset}
                ),
                (LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) > LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_base_offset}))
            ]) {
        1: return switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_apply_base_offset_to_position;
        return switch_graphics_railcar_ruleset_6_unit_sets_whole_divisor_block;
    }

</tal:ruleset>


// railcar 4 unit sets
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_1, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_2, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_3, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        return ${last};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_4, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${special};
        return ${last};
    }

    <!--! if 5 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_5, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        return ${last};
    }

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_6, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        4: return ${special};
        return ${last};
    }

    <!--! if 7 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_7, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${special};
        3: return ${last};
        4: return ${first};
        5: return ${special};
        return ${last};
    }

    <!--! if 8 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_8, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${special};
        3: return ${last};
        4: return ${first};
        5: return ${special};
        6: return ${special};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_length,
            (LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) - LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_base_offset})) % 8
        ) {
        1: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_1;
        2: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_2;
        3: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_3;
        4: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_4;
        5: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_5;
        6: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_6;
        7: return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_7;
        return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 4, just modulo 8 will get the result we need
              we use 8 rather than 4 to allow optional special handling of e.g. 'special' car positions in alternate blocks of 4, in A, B, A, B type pattern
              - !! that might actually be moot for 4-unit sets, where 'special' is the single unit cab car
        -->
            STORE_TEMP(
                LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) % 8,
                ${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) - LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_base_offset}),
                ${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 4 units are there?  Is the unit within a block of 4, or a remainder block?
          we actually control positions out to 8 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 4 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 4 (divisor = 4)
                          - a remainder amount which is at least 4 (and won't be more than 8), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) > 4
                        ?
                        4 * ((LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) / 4) - 1)
                        :
                        0,
                    ${temp_storage_ids.position_in_badge_predicate_chain_base_offset}
                ),
                (LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) >= LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_base_offset}))
            ]) {
        1: return switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position;
        return switch_graphics_railcar_ruleset_4_unit_sets_whole_divisor_block;
    }
</tal:ruleset>

// railcar 3 unit sets
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_1, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_2, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_3, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        return ${last};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_4, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${last};
        2: return ${first};
        return ${last};
    }

    <!--! if 5 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_5, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        return ${last};
    }

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_6, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied})) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        4: return ${special};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_length,
            (LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) - LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_base_offset})) % 6
        ) {
        1: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_1;
        2: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_2;
        3: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_3;
        4: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_4;
        5: return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_5;
        return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_6;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 3, just modulo 6 will get the result we need
              we use 6 rather than 3 to allow optional special handling of e.g. 'special' car positions in alternate blocks of 6, in A, B, A, B type pattern
              - and also precise control over remainder block arrangement (e.g. block of 5 as 2 + 3 or similar)
        -->
            STORE_TEMP(
                LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) % 6,
                ${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_6;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) - LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_base_offset}),
                ${temp_storage_ids.position_in_badge_predicate_chain_with_base_offset_applied}
            ),
        ){
        return switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 3 units are there?  Is the unit within a block of 4, or a remainder block?
          we actually control positions out to 6 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 3 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 3 (divisor = 3)
                          - a remainder amount which is at least 3 (and won't be more than 6), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) > 3
                        ?
                        3 * ((LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) / 3) - 1)
                        :
                        0,
                    ${temp_storage_ids.position_in_badge_predicate_chain_base_offset}
                ),
                (LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) >= LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_base_offset}))
            ]) {
        1: return switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_apply_base_offset_to_position;
        return switch_graphics_railcar_ruleset_3_unit_sets_whole_divisor_block;
    }
</tal:ruleset>


// railcar 2 unit sets
<tal:ruleset define="default 0; first 1; last 2;">
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_1, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) % 4) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_2, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) % 4) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_3, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) % 4) {
        0: return ${first};
        1: return ${last};
        return ${default};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_4, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) % 4) {
        0: return ${first};
        1: return ${last};
        2: return ${first};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_less_than_4_remaining, LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) % 4) {
        1: return switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_1;
        2: return switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_2;
        3: return switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_3;
        return switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_4;
    }

    <!--! given the consist, how many blocks of 4 units are there?  Is the unit within a block of 4, or a remainder block? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain}) >= (LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) - (LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain}) % 4))) {
        1: return switch_graphics_railcar_ruleset_2_unit_sets_less_than_4_remaining;
        return switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_4;
    }
</tal:ruleset>


// tgv/hst ruleset
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_hst_ruleset_position_default, 0) {
        return ${default};
    }

    <!--! if special -->
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_hst_ruleset_position_special_check_length, LOAD_TEMP(${temp_storage_ids.num_vehs_in_badge_predicate_chain})) {
        <!--! don't show 'special' if equivalent id chain < 4 vehicles -->
        0..3: return switch_graphics_tgv_hst_ruleset_position_default;
        return ${special};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_hst_ruleset_position_check_special, [
                LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_from_end}) - LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain})
            ]
        ) {
        0..1: return switch_graphics_tgv_hst_ruleset_position_special_check_length;
        switch_graphics_tgv_hst_ruleset_position_default;
    }

    <!--! if last -->
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_hst_ruleset_position_check_last, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain_from_end})) {
        0: return ${last};
        switch_graphics_tgv_hst_ruleset_position_check_special;
    }
    <!--! if first -->
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_hst_ruleset, LOAD_TEMP(${temp_storage_ids.position_in_badge_predicate_chain})) {
        <!--! TGV cars always show first if at start of equivalent id chain -->
        0: return ${first};
        switch_graphics_tgv_hst_ruleset_position_check_last;
    }
</tal:ruleset>


// driving cab ruleset
<tal:ruleset define="default 0; last 1;">
    <!--! only show 'last' if consist has > 1 vehicle - keeps the cab orientated <- when built in depot, matching buy menu -->
    switch (FEAT_TRAINS, SELF, switch_graphics_driving_cab_car_ruleset_position_last_check_length, num_vehs_in_consist) {
        1: return ${default};
        return ${last};
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_driving_cab_car_ruleset, position_in_consist_from_end) {
        0: switch_graphics_driving_cab_car_ruleset_position_last_check_length;
        return ${default};
    }
</tal:ruleset>


// metro ruleset
<tal:ruleset define="first 0; last 1;">
    switch (FEAT_TRAINS, SELF, switch_graphics_metro_ruleset, position_in_vehid_chain % 2) {
        0: return ${first};
        return ${last};
    }
</tal:ruleset>

