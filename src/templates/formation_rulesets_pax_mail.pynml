<!--! position rulesets for formation-position-dependent vehicles -->

// pax car ruleset
<tal:ruleset define="default 0; first 1; last 2; special 3;">

    <!--! special case to avoid too many things that look like brake coaches, can't be done in the map, has to check actual consist -->
    switch (FEAT_TRAINS, PARENT, switch_graphics_pax_car_ruleset_brake_limiter_last, [
            count_has_badge("ih_formation_ruleset/vehicle_reports_as/looks_like_pax_brake_car")
        ]) {
        0: return ${last};
        return ${special};
    }
    switch (FEAT_TRAINS, PARENT, switch_graphics_pax_car_ruleset_brake_limiter_first, [
            count_has_badge("ih_formation_ruleset/vehicle_reports_as/looks_like_pax_brake_car")
        ]) {
        0: return ${first};
        return ${special};
    }

    <!--! utility to check for restaurant cars -->
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_check_if_restaurant_at_offset, offset, [
            <!--! 0x61 requires register 0x10E to contain the parameter to check - store the badge there -->
            STORE_TEMP(badgetype("ih_formation_ruleset/vehicle_reports_as/restaurant_car"), 0x10E),
            STORE_TEMP(offset, 0x10F),
            var[0x61, 0, 0x00000001, 0x7A],
        ]) {
        return;
    }

    <!--! special case for inner *spaced* brakes to handle case of adjacent restaurant, by recovering brake via a latent pair provided in the map -->
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_if_restaurant_preceding_recover_brake_inner_spaced, [
            switch_graphics_pax_car_ruleset_check_if_restaurant_at_offset(-1)
        ]) {
        1: return ${first};
        return ${special};
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_if_restaurant_following_recover_brake_inner_spaced, [
            switch_graphics_pax_car_ruleset_check_if_restaurant_at_offset(1)
        ]) {
        1: return switch_graphics_pax_car_ruleset_brake_limiter_last;
        return ${special};
    }

    <!--! special case for inner *paired* brakes to handle case of adjacent restaurant, by recovering pair via a latent triple provided in the map -->
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_if_restaurant_adjacent_flip_brake_inner_paired, [
            switch_graphics_pax_car_ruleset_check_if_restaurant_at_offset(-1)
        ]) {
        1: return ${first};
        return switch_graphics_pax_car_ruleset_brake_limiter_last;
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset_if_restaurant_adjacent_recover_brake_inner_paired, [
            switch_graphics_pax_car_ruleset_check_if_restaurant_at_offset(-1)
            ||
            switch_graphics_pax_car_ruleset_check_if_restaurant_at_offset(-2)
        ]) {
        1: return switch_graphics_pax_car_ruleset_brake_limiter_last;
        return ${special};
    }

    switch (FEAT_TRAINS, PARENT, switch_graphics_pax_car_ruleset_random_category, [
            <!--! 3 categories, but pick 3 bits and distribute the random weight across 8 entries -->
            getbits(var[0x5F, 8, 0x00FFFFFF], 0, 3)
        ]) {
        <!--! most common -->
        0: pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_brakes_outer_ends(LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain));
        1: pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_brakes_outer_ends(LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain));
        2: pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_brakes_outer_ends(LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain));

        3: pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_brakes_inner_spaced(LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain));
        4: pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_brakes_inner_spaced(LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain));
        5: pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_brakes_inner_spaced(LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain));
        <!--! least common -->
        6: pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_brakes_inner_paired(LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain));
        7: pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_brakes_inner_paired(LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain));
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_pax_car_ruleset, [
            switch_graphics_pax_car_ruleset_random_category()
        ]) {
        <!--! type A: paired inner brakes; with minimal magic
              - end brake will disappear anyway if adjacent cab car or mail car
              - restaurant special handling not worth the candle as of April 2025
        -->
        100: return ${default};
        101: return ${first};
        102: return ${last};
        103: return ${special};
        <!--! type B: paired inner brakes, with more magic -->
        200: return ${default};
        201: return ${first};
        202: switch_graphics_pax_car_ruleset_if_restaurant_adjacent_flip_brake_inner_paired;
        204: switch_graphics_pax_car_ruleset_if_restaurant_adjacent_recover_brake_inner_paired;
        203: return ${special};
        <!--! type C: spaced inner brakes, with more magic -->
        300: return ${default};
        301: ${first};
        304: switch_graphics_pax_car_ruleset_if_restaurant_preceding_recover_brake_inner_spaced;
        305: switch_graphics_pax_car_ruleset_if_restaurant_following_recover_brake_inner_spaced;
        302: switch_graphics_pax_car_ruleset_brake_limiter_last;
        303: return ${special};
        <!--! shouldn't be reached, maps are pre-determined -->
        return ${default};
    }
</tal:ruleset>


// restaurant car ruleset
<tal:ruleset define="first 1; last 2;">
    <!--! for simple variety, restaurant cars abuse first / last to random reverse the sprites in the ruleset (the vehicle is *not* reversed) -->
    switch (FEAT_TRAINS, SELF, switch_graphics_restaurant_car_ruleset, [
             getbits(var[0x5F, 8, 0x00FFFFFF], 0, 1)
        ]) {
        1: return ${first};
        return ${last};
    }
</tal:ruleset>


// mail car ruleset - delegates to pre-generated pseudo-random maps
<tal:ruleset define="default 0; first 1; last 2; special 3;">

    <!--! we do a couple of specific things here to get an appropriate weight fom the pseudo random maps:
          - we *don't* switch the target map for all vehicles as the length changes, it looks weird because the consist changes as vehicles are added removed
          - we do offset into specific maps depending on vehicle position, as it's guaranteed that e.g.
             - short lengths such as 3 or 6 will have a good vehicle mix (this is enforced in the generator)
             - whereas offsetting short chains straight into the 32 map might not be pleasing result, as the first part of the map may have low entropy
          -->
    <!--! cabbage - this could probably just have used a set of 64 length maps, with better map gen rules, like pax cars distribute brake coaches -->
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset_select_appropriate_map_length, [
            LOAD_TEMP(k_addr_position_in_badge_predicate_chain)
        ]) {
        0: return pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE(1); <!--! no special sprites for length 1, by design (relies on the maps) -->
        1..3: return pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE(3);
        4..7: return pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE(8);
        8..15: return pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE(16);
        return pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE(32);
    }
    switch (FEAT_TRAINS, SELF, switch_graphics_mail_car_ruleset, [
            switch_graphics_mail_car_ruleset_select_appropriate_map_length()
        ]) {
        0: return ${first};
        1: return ${last};
        2: return ${special};
        return ${default}; <!--! shouldn't be reached, maps are pre-determined to 0, 1, 2 -->
    }
</tal:ruleset>


// railcar 6 unit sets
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    <!--! there is never 1 unit for this ruleset, always minimum 2 -->

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_2, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        return ${last};
    }

    <!--! there are never 3 units for this ruleset, always multiple of 2 -->

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_4, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        return ${last};
    }

    <!--! there are never 5 units for this ruleset, always multiple of 2 -->

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_6, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${default};
        2: return ${default};
        3: return ${special};
        4: return ${default};
        return ${last};
    }

    <!--! there are never 7 units for this ruleset, always multiple of 2 -->

    <!--! if 8 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_8, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        3: return ${last};
        4: return ${first};
        5: return ${default};
        6: return ${default};
        return ${last};
    }

    <!--! there are never 9 units for this ruleset, always multiple of 2 -->

    <!--! if 10 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_10, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        3: return ${default};
        4: return ${last};
        5: return ${first};
        6: return ${default};
        7: return ${default};
        8: return ${default};
        return ${last};
    }

    <!--! there are never 11 units for this ruleset, always multiple of 2 -->

    <!--! if 12 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_12, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${default};
        2: return ${special};
        3: return ${default};
        4: return ${default};
        5: return ${last};
        6: return ${first};
        7: return ${default};
        8: return ${default};
        9: return ${special};
        10: return ${default};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_length,
            (LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) - LOAD_TEMP(k_addr_position_in_badge_predicate_chain_base_offset)) % 12
        ) {
        <!--! there is never 1 unit for this ruleset, always minimum 2 -->
        2: switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_2;
        <!--! there are never 3 units for this ruleset, always multiple of 2 -->
        4: switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_4;
        <!--! there are never 5 units for this ruleset, always multiple of 2 -->
        6: switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_6;
        <!--! there are never 7 units for this ruleset, always multiple of 2 -->
        8: switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_8;
        <!--! there are never 9 units for this ruleset, always multiple of 2 -->
        10: switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_10;
        <!--! there are never 11 units for this ruleset, always multiple of 2 -->
        switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_12;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 6, just modulo 12 will get the result we need
              we use 12 rather than 6 to allow special handling of e.g. restaurant car position in alternate blocks of 6, in A, B, A, B type pattern
              - and also precise control over remainder block arrangement (e.g. block of 5 as 2 + 3 or similar)
            -->
            STORE_TEMP(
                LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % 12,
                k_addr_position_in_badge_predicate_chain_with_base_offset_applied
            ),
        ){
        switch_graphics_railcar_ruleset_6_unit_sets_modulo_num_units_in_formation_12;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                LOAD_TEMP(k_addr_position_in_badge_predicate_chain) - LOAD_TEMP(k_addr_position_in_badge_predicate_chain_base_offset),
                k_addr_position_in_badge_predicate_chain_with_base_offset_applied
            ),
        ){
        switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 6 units are there?  Is the unit within a block of 6, or a remainder block?
          we actually control positions out to 12 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_6_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 6 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 6 (divisor = 6)
                          - a remainder amount which is at least 6 (and won't be more than 12), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) > 6
                        ?
                        6 * ((LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) / 6) - 1)
                        :
                        0,
                    k_addr_position_in_badge_predicate_chain_base_offset
                ),
                (LOAD_TEMP(k_addr_position_in_badge_predicate_chain) > LOAD_TEMP(k_addr_position_in_badge_predicate_chain_base_offset))
            ]) {
        1: switch_graphics_railcar_ruleset_6_unit_sets_check_remainder_block_apply_base_offset_to_position;
        switch_graphics_railcar_ruleset_6_unit_sets_whole_divisor_block;
    }

</tal:ruleset>


// railcar 4 unit sets
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_1, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_2, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_3, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${special};
        return ${last};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_4, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${special};
        2: return ${special};
        return ${last};
    }

    <!--! if 5 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_5, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        return ${last};
    }

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_6, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        4: return ${special};
        return ${last};
    }

    <!--! if 7 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_7, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${special};
        2: return ${special};
        3: return ${last};
        4: return ${first};
        5: return ${special};
        return ${last};
    }

    <!--! if 8 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_8, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${special};
        2: return ${special};
        3: return ${last};
        4: return ${first};
        5: return ${special};
        6: return ${special};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_length,
            (LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) - LOAD_TEMP(k_addr_position_in_badge_predicate_chain_base_offset)) % 8
        ) {
        1: switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_1;
        2: switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_2;
        3: switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_3;
        4: switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_4;
        5: switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_5;
        6: switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_6;
        7: switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_7;
        switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 4, just modulo 8 will get the result we need
              we use 8 rather than 4 to allow optional special handling of e.g. 'special' car positions in alternate blocks of 4, in A, B, A, B type pattern
              - !! that might actually be moot for 4-unit sets, where 'special' is the single unit cab car
        -->
            STORE_TEMP(
                LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % 8,
                k_addr_position_in_badge_predicate_chain_with_base_offset_applied
            ),
        ){
        switch_graphics_railcar_ruleset_4_unit_sets_modulo_num_units_in_formation_8;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                LOAD_TEMP(k_addr_position_in_badge_predicate_chain) - LOAD_TEMP(k_addr_position_in_badge_predicate_chain_base_offset),
                k_addr_position_in_badge_predicate_chain_with_base_offset_applied
            ),
        ){
        switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 4 units are there?  Is the unit within a block of 4, or a remainder block?
          we actually control positions out to 8 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_4_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 4 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 4 (divisor = 4)
                          - a remainder amount which is at least 4 (and won't be more than 8), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) > 4
                        ?
                        4 * ((LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) / 4) - 1)
                        :
                        0,
                    k_addr_position_in_badge_predicate_chain_base_offset
                ),
                (LOAD_TEMP(k_addr_position_in_badge_predicate_chain) >= LOAD_TEMP(k_addr_position_in_badge_predicate_chain_base_offset))
            ]) {
        1: switch_graphics_railcar_ruleset_4_unit_sets_check_remainder_block_apply_base_offset_to_position;
        switch_graphics_railcar_ruleset_4_unit_sets_whole_divisor_block;
    }
</tal:ruleset>

// railcar 3 unit sets
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_1, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_2, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_3, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${special};
        return ${last};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_4, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${last};
        2: return ${first};
        return ${last};
    }

    <!--! if 5 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_5, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        return ${last};
    }

    <!--! if 6 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_6, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_with_base_offset_applied)) {
        0: return ${first};
        1: return ${special};
        2: return ${last};
        3: return ${first};
        4: return ${special};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_length,
            (LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) - LOAD_TEMP(k_addr_position_in_badge_predicate_chain_base_offset)) % 6
        ) {
        1: switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_1;
        2: switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_2;
        3: switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_3;
        4: switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_4;
        5: switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_5;
        switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_6;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_whole_divisor_block,
        <!--! for whole blocks of 3, just modulo 6 will get the result we need
              we use 6 rather than 3 to allow optional special handling of e.g. 'special' car positions in alternate blocks of 6, in A, B, A, B type pattern
              - and also precise control over remainder block arrangement (e.g. block of 5 as 2 + 3 or similar)
        -->
            STORE_TEMP(
                LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % 6,
                k_addr_position_in_badge_predicate_chain_with_base_offset_applied
            ),
        ){
        switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_6;
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_apply_base_offset_to_position,
            STORE_TEMP(
                <!--! store the vehicle position in equivalent-id chain, but with the base offset applied -->
                LOAD_TEMP(k_addr_position_in_badge_predicate_chain) - LOAD_TEMP(k_addr_position_in_badge_predicate_chain_base_offset),
                k_addr_position_in_badge_predicate_chain_with_base_offset_applied
            ),
        ){
        switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_length;
    }

    <!--! given the consist, how many blocks of 3 units are there?  Is the unit within a block of 4, or a remainder block?
          we actually control positions out to 6 units, as we want specific combinations up to that limit -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_3_unit_sets,
            [
                STORE_TEMP(
                    <!--! how many blocks of 3 will fit in the total consist?
                          then remove one, because we want
                          - n whole blocks of 3 (divisor = 3)
                          - a remainder amount which is at least 3 (and won't be more than 6), to which we apply special rules
                          this is to ensure we don't get isolated blocks of 2 cab units at the end of formations that are > 12 units long
                          note we multiply the n-1 block count by the divisor to store an *actual* position in the relative ID chain, which we will use to split behaviour on later
                    -->
                    LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) > 3
                        ?
                        3 * ((LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) / 3) - 1)
                        :
                        0,
                    k_addr_position_in_badge_predicate_chain_base_offset
                ),
                (LOAD_TEMP(k_addr_position_in_badge_predicate_chain) >= LOAD_TEMP(k_addr_position_in_badge_predicate_chain_base_offset))
            ]) {
        1: switch_graphics_railcar_ruleset_3_unit_sets_check_remainder_block_apply_base_offset_to_position;
        switch_graphics_railcar_ruleset_3_unit_sets_whole_divisor_block;
    }
</tal:ruleset>


// railcar 2 unit sets
<tal:ruleset define="default 0; first 1; last 2;">
    <!--! if 1 unit in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_1, LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % 4) {
        0: return ${default};
    }

    <!--! if 2 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_2, LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % 4) {
        0: return ${first};
        return ${last};
    }

    <!--! if 3 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_3, LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % 4) {
        0: return ${first};
        1: return ${last};
        return ${default};
    }

    <!--! if 4 units in sequence -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_4, LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % 4) {
        0: return ${first};
        1: return ${last};
        2: return ${first};
        return ${last};
    }

    <!--! this is a remainder block, how many units are in it? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets_less_than_4_remaining, LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) % 4) {
        1: switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_1;
        2: switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_2;
        3: switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_3;
        switch_graphics_railcar_ruleset_3_unit_sets_modulo_num_units_in_formation_4;
    }

    <!--! given the consist, how many blocks of 4 units are there?  Is the unit within a block of 4, or a remainder block? -->
    switch (FEAT_TRAINS, SELF, switch_graphics_railcar_ruleset_2_unit_sets, LOAD_TEMP(k_addr_position_in_badge_predicate_chain) >= (LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) - (LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) % 4))) {
        1: switch_graphics_railcar_ruleset_2_unit_sets_less_than_4_remaining;
        switch_graphics_railcar_ruleset_2_unit_sets_modulo_num_units_in_formation_4;
    }
</tal:ruleset>


// tgv/hst ruleset
<tal:ruleset define="default 0; first 1; last 2; special 3;">
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_hst_ruleset_position_default, 0) {
        return ${default};
    }

    <!--! if special -->
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_hst_ruleset_position_special_check_length, LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain)) {
        <!--! don't show 'special' if equivalent id chain < 4 vehicles -->
        0..3: switch_graphics_tgv_hst_ruleset_position_default;
        return ${special};
    }
    switch (FEAT_TRAINS, PARENT, switch_graphics_tgv_hst_ruleset_position_check_special, [
                (LOAD_TEMP(k_addr_position_in_badge_predicate_chain_from_end) - LOAD_TEMP(k_addr_position_in_badge_predicate_chain))
                +
                <!--! pick a random bit from the engine to provide a minimal amount of variation in special sprite position between consists -->
                getbits(var[0x5F, 8, 0x00FFFFFF], 0, 1)
            ]
        ) {
        0..1: switch_graphics_tgv_hst_ruleset_position_special_check_length;
        switch_graphics_tgv_hst_ruleset_position_default;
    }

    <!--! if last -->
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_hst_ruleset_position_check_last, LOAD_TEMP(k_addr_position_in_badge_predicate_chain_from_end)) {
        0: return ${last};
        switch_graphics_tgv_hst_ruleset_position_check_special;
    }
    <!--! if first -->
    switch (FEAT_TRAINS, SELF, switch_graphics_tgv_hst_ruleset, LOAD_TEMP(k_addr_position_in_badge_predicate_chain)) {
        <!--! TGV cars always show first if at start of equivalent id chain -->
        0: return ${first};
        switch_graphics_tgv_hst_ruleset_position_check_last;
    }
</tal:ruleset>


// driving cab ruleset
<tal:ruleset define="default 0; last 1;">
    <!--! only show 'last' if consist has > 1 vehicle - keeps the cab orientated <- when built in depot, matching buy menu -->
    switch (FEAT_TRAINS, SELF, switch_graphics_driving_cab_car_ruleset_position_last_check_length, num_vehs_in_consist) {
        1: return ${default};
        return ${last};
    }

    switch (FEAT_TRAINS, SELF, switch_graphics_driving_cab_car_ruleset, position_in_consist_from_end) {
        0: switch_graphics_driving_cab_car_ruleset_position_last_check_length;
        return ${default};
    }
</tal:ruleset>


// metro ruleset
<tal:ruleset define="first 0; last 1;">
    switch (FEAT_TRAINS, SELF, switch_graphics_metro_ruleset, LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % 2) {
        0: return ${first};
        return ${last};
    }
</tal:ruleset>

