<!--! graphics chain for vehicle platform and masked overlay -->
<tal:spritesets repeat="spriteset_data model_variant.gestalt_graphics.get_unique_spritesets(unit)">
    <!--! spriteset loops got too complex in the templates, with livery, empty state, cargo loading, cargo loaded, and random variants
          so I moved the logic for spritesets into the gestalt, and simply render out all from a list with a trivial loop -->
    spriteset(${unit.id}_ss_${spriteset_data[0]}, "${graphics_path}${model_variant.model_id}.png") {
        ${unit.get_spriteset_template_name('unreversed', spriteset_data[1])}
    }
    <!--! spritegroups aren't used here, direct to spriteset -->
</tal:spritesets>

switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_vehicle_get_recolour_map_random_choice, [
            switch_pseudo_random_freight_ruleset_map_for_random_choice_${model_variant.gestalt_graphics.formation_ruleset}()
        ]) {
    return;
}

<tal:spritelayer_vehicle_layers repeat="vehicle_spritelayer_name model_variant.gestalt_graphics.vehicle_spritelayer_names">
    switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_${vehicle_spritelayer_name}_position_in_formation_entry_point,
        [
            STORE_TEMP(CB_FLAG_MORE_SPRITES | switch_freight_wagon_livery_entry_point(${unit.id}_switch_graphics_vehicle_get_recolour_map_random_choice()), 0x100),
            10 + switch_graphics_automobile_transporter_ruleset_${model_variant.gestalt_graphics.formation_ruleset}()
        ]
    ) {
        <tal:position_ruleset repeat="formation_position_label model_variant.gestalt_graphics.formation_position_labels">
            ${10 + repeat.formation_position_label.index}: ${unit.id}_ss_${vehicle_spritelayer_name}_${formation_position_label};
        </tal:position_ruleset>
    }
</tal:spritelayer_vehicle_layers>

<tal:spritelayer_cargo_layers repeat="platform_type model_variant.spritelayer_cargo_layers">
    <!--! load state is assumed (for simplicity) to be all or nothing - any cargo = full load of automobile cargos -->
    switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_spritelayer_cargos_check_cargo_count_${platform_type}, cargo_count) {
            0: return ss_global_empty_vehicle;
        return switch_spritelayer_cargos_unreversed_${spritelayer_cargos.automobiles.AutomobilesSpritelayerCargo().base_id}_${platform_type}_${4 * unit.vehicle_length}px;
    }

    switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_spritelayer_cargos_${platform_type}, [
                         STORE_TEMP(CB_FLAG_MORE_SPRITES | PALETTE_USE_DEFAULT, 0x100), <!--! note requirement to pass along 'more sprites' flag here -->
                         STORE_TEMP(1, k_addr_unreversible_spritelayer_cargos) <!--! no reverse on cargo sprites -->
                        ]) {
        return ${unit.id}_switch_graphics_spritelayer_cargos_check_cargo_count_${platform_type};
    }
</tal:spritelayer_cargo_layers>

<!--! (conditional) stuff any temp storages needed for use with the var_41_but_badges_not_ids magic -->
switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_vehicle_init_alt_var_41, [
        initialise_alt_var_41_with_badge_predicate(badgetype("ih_formation_ruleset/vehicle_reports_as/${model_variant.gestalt_graphics.badge_slug_for_alt_var_41_predicate}"))
    ]) {
    return;
}

<!--! switch layers: base platform / spritelayer cargo -->
switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_vehicle, [
        ${unit.id}_switch_graphics_vehicle_init_alt_var_41(),
        getbits(extra_callback_info1, 8, 8)
    ]) {
    0: return ${unit.id}_switch_graphics_base_platform_position_in_formation_entry_point;
    <tal:optional_lower_deck condition="len(model_variant.spritelayer_cargo_layers) > 0">
    1: return ${unit.id}_switch_graphics_spritelayer_cargos_${model_variant.spritelayer_cargo_layers[0]};
    </tal:optional_lower_deck>
    <tal:optional_masked_overlay condition="model_variant.gestalt_graphics.add_masked_overlay">
        2: return ${unit.id}_switch_graphics_masked_overlay_position_in_formation_entry_point;
    </tal:optional_masked_overlay>
    <tal:optional_upper_deck condition="len(model_variant.spritelayer_cargo_layers) == 2">
        3: return ${unit.id}_switch_graphics_spritelayer_cargos_${model_variant.spritelayer_cargo_layers[1]};
    </tal:optional_upper_deck>
}


<tal:buy_menu_lead_unit_only condition="unit.is_not_trailing_part">
    <!--! buy menu graphics chain -->
    spriteset(${unit.id}_ss_vehicle_purchase, "${graphics_path}${model_variant.model_id}.png") {
        ${model_variant.get_nml_for_spriteset_template(y_offset=0)}
    }
    switch (FEAT_TRAINS, SELF, ${unit.id}_switch_graphics_purchase, 0) {
        0: return ${unit.id}_ss_vehicle_purchase;
    }
</tal:buy_menu_lead_unit_only>




