item(FEAT_TRAINS, ${unit.id}, ${unit.numeric_id}) {
    property {
        <!--! name static prop used for buy menu search only -->
        name:                           ${model_variant.name_as_nml_prop};
        badges:                         ${model_variant.badges_as_nml_prop};
        <!--! hide trailing parts from buy menu -->
        climates_available:             ${"NO_CLIMATE" if unit.is_trailing_part else "ALL_CLIMATES"};
        <tal:not_trailing_parts condition="unit.is_not_trailing_part">
            <!--! some properties should not be set for trailing parts of articulated vehicles -->
            engine_class:                   ${unit.engine_class};
            introduction_date:              date(${catalogue.intro_year}, ${1 + model_variant.intro_date_months_offset}, 1);
            power:                          ${model_variant.power}hp;
            weight:                         ${model_variant.weight}ton;
            tractive_effort_coefficient:    ${model_variant.tractive_effort_coefficient};
            cost_factor:                    0; <!--! use the CB to set this, the prop is capped to max 255, cb is 32k -->
            running_cost_base:              ${unit.running_cost_base};
            running_cost_factor:            0; <!--! use the CB to set this, the prop is capped to max 255, cb is 32k -->
            model_life:                     ${model_variant.model_life};
            retire_early:                   ${model_variant.retire_early};
            reliability_decay:              20; <!--! default value -->
            vehicle_life:                   ${model_variant.vehicle_life};
            <tal:variant_group condition="model_variant.variant_group_as_nml_prop is not None">
                variant_group:                  ${model_variant.variant_group_as_nml_prop};
            </tal:variant_group>
        </tal:not_trailing_parts>
        <tal:trailing_parts_only condition="unit.is_trailing_part">
            <!--! some properties must be explicitly set to 0 for trailing parts -->
            <!--! note that power cannot be 0 for engines, even this violates spec as of Nov 2022
                  - for details see https://github.com/OpenTTD/OpenTTD/issues/10146 -->
            power:                          ${1 if model_variant.power != 0 else 0};
            weight:                         0;
            tractive_effort_coefficient:    0;
            cost_factor:                    0;
            running_cost_base:              RUNNING_COST_NONE;
            running_cost_factor:            0;
        </tal:trailing_parts_only>
        <tal:speed_is_optional condition="model_variant.speed is not None">
            speed:                          ${model_variant.speed}mph;
        </tal:speed_is_optional>
        cargo_capacity:                 ${unit.default_cargo_capacity};
        sprite_id:                      SPRITE_ID_NEW_TRAIN;
        refit_cost:                     0; <!--! btw this needs to be 0 if we want autorefit without using cb -->
        refittable_cargo_classes:       ${unit.get_cargo_classes_as_nml_prop('allowed')};
        non_refittable_cargo_classes:   ${unit.get_cargo_classes_as_nml_prop('disallowed')};
        cargo_allow_refit:              [${model_variant.label_refits_allowed_as_nml_prop}];
        cargo_disallow_refit:           [${model_variant.label_refits_disallowed_as_nml_prop}];
        <tal:default_cargo condition="len(model_variant.default_cargos) > 0">
            default_cargo_type:             ${model_variant.get_nml_expression_for_default_cargos()};
        </tal:default_cargo>
        <tal:loading_speed condition="unit.has_cargo_capacity">
            loading_speed:                  ${unit.loading_speed};
        </tal:loading_speed>
        misc_flags:                     bitmask(${unit.misc_flags});
        extra_flags:                    bitmask(${unit.extra_flags});
        dual_headed:                    ${1 if model_variant.dual_headed else 0};
        length:                         ${unit.vehicle_length};
        track_type:                     ${model_variant.track_type};
        effect_spawn_model_and_powered: EFFECT_SPAWN_MODEL_NONE; <!--! default to none to suppress effects, set in cb as needed -->
    }
    graphics {
        default:                        ${unit.graphics_switch_entry_point_stem}_switch_graphics;
        <tal:not_trailing_parts condition="unit.is_not_trailing_part">
            purchase:                       ${unit.graphics_switch_entry_point_stem}_switch_graphics_purchase;
            <tal:name_callback condition="model_variant.use_name_callback">
                name:                           switch_name();
            </tal:name_callback>
            <!--! certain callbacks should not be handled for trailing parts of articulated vehicles -->
            cost_factor:                    ${model_variant.buy_cost}; <!--! CB used as it is capped to max 32k, prop is only 255 -->
            <tal:running_cost_factor switch="getattr(model_variant, 'affected_by_restaurant_car_in_consist', False)">
                <!--! CB should be used even for static running costs as it is capped to max 32k, prop is only 255 -->
                <tal:block case="True">
                    running_cost_factor:            ${model_variant.model_id}_switch_running_cost_factor;
                </tal:block
                <tal:block case="False">
                    running_cost_factor: ${model_variant.running_cost};
                </tal:block>
            </tal:running_cost_factor>
            <!--! purchase set separately to prevent unreliable results from trying to access non-available vars for variable run costs -->
            purchase_running_cost_factor:   ${model_variant.running_cost};
            <tal:variable_power condition="model_variant.engine_varies_power_by_power_source or model_variant.is_distributed_power_wagon">
                power:                          ${model_variant.model_id}_switch_power_0;
                purchase_power:                 ${model_variant.power};
            </tal:variable_power>
            <tal:speed_is_optional condition="model_variant.receives_easter_egg_haulage_speed_bonus or model_variant.lgv_capable">
                speed:                          ${model_variant.model_id}_switch_speed;
                purchase_speed:                 ${int(1.60934 * model_variant.speed)};
            </tal:speed_is_optional>
            <tal:add_articulated_parts condition="len(model_variant.units) > 1">
                articulated_part: ${model_variant.id}_articulated_cb_switch;
            </tal:add_articulated_parts>
            <!--! setting buy menu text for engines and some wagons with role set currently - this is starting to look jank AF eh-->
            <tal:buy_menu_additional_text condition="model_variant.uses_buy_menu_additional_text">
                additional_text:                ${model_variant.model_id}_switch_buy_menu_additional_text;
            </tal:buy_menu_additional_text>
        </tal:not_trailing_parts>
        <tal:conditional_random_trigger condition="unit.random_trigger_switch is not None">
            <!--! NOTE that dual headed units should avoid random triggers as of Dec 2020 - there is an undiagnosed with bug rear unit running unwanted triggers and re-randomising in depots etc -->
            random_trigger:                 ${unit.id + unit.random_trigger_switch};
        </tal:conditional_random_trigger>
        <tal:colour_mapping_cb switch="unit.requires_colour_mapping_cb">
            <tal:use_colour_randomisation_strategies case="'use_colour_randomisation_strategies'">
                colour_mapping:                 switch_freight_wagon_livery_entry_point(random_bits_wagon_random_remap_livery());
                purchase_colour_mapping:        switch_freight_wagon_livery_entry_point_purchase();
            </tal:use_colour_randomisation_strategies>
            <tal:colour_mapping_switch_with_purchase case="'colour_mapping_switch_with_purchase'">
                colour_mapping:                 ${unit.id + model_variant.gestalt_graphics.colour_mapping_switch};
                purchase_colour_mapping:        ${unit.id + model_variant.gestalt_graphics.colour_mapping_switch_purchase};
            </tal:colour_mapping_switch_with_purchase
        </tal:colour_mapping_cb>
        <!--! only use the capacity switches if unit carries cargo, makes faster compile (saved about 20% of time) -->
        <tal:optional_capacity_switches condition="unit.has_cargo_capacity">
            cargo_capacity:                 ${unit.unit_id_from_default_model_variant_id}_switch_cargo_capacity;
            purchase_cargo_capacity:        ${unit.unit_id_from_default_model_variant_id}_switch_cargo_capacity;
        </tal:optional_capacity_switches>
        <!--! as of May 2021 cargo subtype use is specific to vehicles transporters, extend in future if needed -->
        <!--! as of April 2025 this is not used, only type of automotive sprites exists -->
        <!--!
        <tal:optional_cargo_subtype condition="getattr(model_variant, 'use_cargo_subytpes_VEHI', False)">
            cargo_subtype_text: switch_cargo_subtype_text();
        </tal:optional_cargo_subtype>
        -->
        <!--! only use the visual effect switches if needed, saves a couple of seconds on compile -->
        <tal:create_effect condition="len(unit.effects) > 0">
            effect_spawn_model_and_powered: ${unit.id}_switch_effect_spawn_model_and_powered;
            create_effect:      ${unit.id}_switch_create_effect_check_railtype;
        </tal:create_effect>
        <tal:random_reverse_on_build condition="model_variant.random_reverse">
            <!--! 50% chance of being reversed when built, if this property is set (player bool parameter can turn this off) -->
            reverse_build_probability: return 50 * param_vehicle_random_reverse_on_build;
        </tal:random_reverse_on_build>
    }
}

<tal:rosters condition="unit.is_not_trailing_part">
    <!--! constructing combinatorial 'if' expressions is too complicated, just turn the unit off in a cascading way that will probably go wrong eh? -->
    <tal:vehicle_availability_engines condition="catalogue.engine_quacker.availability_controlled_by_engine_param">
        <tal:simplified_gameplay_only_mode condition="model_variant.joker or not model_variant.is_default_model_variant">
            if (param_vehicle_availability_engines==1) {
                item(FEAT_TRAINS, ${unit.id}, ${unit.numeric_id}) {
                    property {
                        climates_available:             NO_CLIMATE;
                        variant_group:                  0xFFFF; <!--! equivalent of INVALID_ENGINE - no variant group -->
                    }
                }
            }
        </tal:simplified_gameplay_only_mode>
        if (param_vehicle_availability_engines==2) {
            item(FEAT_TRAINS, ${unit.id}, ${unit.numeric_id}) {
                property {
                    climates_available:             NO_CLIMATE;
                }
            }
        }
    </tal:vehicle_availability_engines>
    <tal:vehicle_availability_wagons condition="catalogue.wagon_quacker.availability_controlled_by_wagon_param">
        <tal:simplified_gameplay_only_mode condition="model_variant.joker or not model_variant.is_default_model_variant">
            if (param_vehicle_availability_wagons==1) {
                item(FEAT_TRAINS, ${unit.id}, ${unit.numeric_id}) {
                    property {
                        climates_available:             NO_CLIMATE;
                        variant_group:                  0xFFFF; <!--! equivalent of INVALID_ENGINE - no variant group -->
                    }
                }
            }
        </tal:simplified_gameplay_only_mode>
        if (param_vehicle_availability_wagons==2) {
            item(FEAT_TRAINS, ${unit.id}, ${unit.numeric_id}) {
                property {
                    climates_available:             NO_CLIMATE;
                }
            }
        }
    </tal:vehicle_availability_wagons>
</tal:rosters>

