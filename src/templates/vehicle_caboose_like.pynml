<!--! this is the template for caboose cars, also spacer cars etc
      this handles both randomised and non-randomised variants
-->

<!--! shared procedures -->
<tal:model_common condition="model_variant.is_default_model_variant">
    switch (FEAT_TRAINS, SELF, ${unit.unit_id_from_default_model_variant_id}_switch_check_date, current_year) {
        <tal:caboose_variants repeat="variant_date_range model_variant.buy_menu_variants_by_date_cabbage">
            ${variant_date_range[1][0]}..${variant_date_range[1][1]}: return ${variant_date_range[0]};
        </tal:caboose_variants>
    }
</tal:model_common>

<!--! non-randomised caboose -->
<tal:non_randomised_caboose condition="not catalogue.wagon_quacker.is_randomised_caboose">
    <tal:model_common condition="model_variant.is_default_model_variant">

            <tal:caboose_variants repeat="variant_date_range model_variant.buy_menu_variants_by_date_cabbage">
                spriteset(${unit.unit_id_from_common_model_id}_ss_${variant_date_range[0]}, "${graphics_path}${model_variant.model_id}.png") {
                    ${unit.get_spriteset_template_name('unreversed', 10 + (repeat.variant_date_range.index * 30))}
                }
            </tal:caboose_variants>
            switch (FEAT_TRAINS, SELF, ${unit.unit_id_from_default_model_variant_id}_switch_graphics_vehicle, [
                    ${unit.unit_id_from_default_model_variant_id}_switch_check_date()
                ]) {
                <tal:caboose_variants repeat="date_variant_item model_variant.buy_menu_variants_by_date_cabbage">
                    ${date_variant_item[0]}: return ${unit.unit_id_from_common_model_id}_ss_${date_variant_item[0]};
                </tal:caboose_variants>

            }

            <tal:buy_menu_lead_unit_only condition="unit.is_not_trailing_part">
                <!--! purchase sprites always go through a switch in case the template does anything specific for purchase graphics
                      when there is nothing specific, then this is just a null switch -->
                <tal:caboose_variants repeat="variant_date_range model_variant.buy_menu_variants_by_date_cabbage">
                    spriteset(${model_variant.model_id}_ss_purchase_${variant_date_range[0]}, "${graphics_path}${model_variant.model_id}.png") {
                        ${model_variant.get_nml_for_spriteset_template(y_offset=repeat.variant_date_range.index * 30)}
                    }
                </tal:caboose_variants>
                switch (FEAT_TRAINS, SELF, ${unit.unit_id_from_common_model_id}_switch_graphics_purchase, [
                        ${unit.unit_id_from_default_model_variant_id}_switch_check_date()
                    ]) {
                    <tal:caboose_variants repeat="date_variant_item model_variant.buy_menu_variants_by_date_cabbage">
                        ${date_variant_item[0]}: return ${model_variant.model_id}_ss_purchase_${date_variant_item[0]};
                    </tal:caboose_variants>
                }
            </tal:buy_menu_lead_unit_only>

    </tal:model_common>
</tal:non_randomised_caboose>

<!--! randomised caboose -->
<tal:randomised_caboose condition="catalogue.wagon_quacker.is_randomised_caboose">
    <tal:model_common condition="model_variant.is_default_model_variant">

        switch (FEAT_TRAINS, SELF, ${unit.unit_id_from_common_model_id}_switch_graphics, [
                pseudo_random_value_from_freight_entropic_map_map_loose_mixed_train()
                <!--! modulo to cap the value selected (range 64) to the range of actual candidates -->
                %
                ${len(model_variant.wagon_randomisation_candidates)}
            ]) {
            <tal:randomisation_candidates repeat="randomisation_candidate model_variant.wagon_randomisation_candidates">
                <!--! the id interpolation is JFDI
                    - possibly should be using unit.unit_index_in_model_variant instead of model_variant.units.index(unit)
                    - or possibly it should at least by using unique_units
                    - may not matter for non-articulated cases
                    - this is untested with articulated vehicles and random articulated vehicles may simply not work at all -->
                ${repeat.randomisation_candidate.index}: ${randomisation_candidate.model_id}_unit_${model_variant.units.index(unit)}_switch_graphics;
            </tal:randomisation_candidates>
        }

        <tal:buy_menu_lead_unit_only condition="unit.is_not_trailing_part">
            <!--! purchase sprites always go through a switch in case the template does anything specific for purchase graphics
                  when there is nothing specific, then this is just a null switch -->
                <tal:caboose_variants repeat="variant_date_range model_variant.buy_menu_variants_by_date_cabbage">
                    spriteset(${model_variant.model_id}_ss_purchase_${variant_date_range[0]}, "${graphics_path}${model_variant.model_id}.png") {
                        ${model_variant.get_nml_for_spriteset_template(y_offset=repeat.variant_date_range.index * 30)}
                    }
                </tal:caboose_variants>
                switch (FEAT_TRAINS, SELF, ${unit.unit_id_from_common_model_id}_switch_graphics_purchase, [
                        ${unit.unit_id_from_default_model_variant_id}_switch_check_date()
                    ]) {
                    <tal:caboose_variants repeat="date_variant_item model_variant.buy_menu_variants_by_date_cabbage">
                        ${date_variant_item[0]}: return ${model_variant.model_id}_ss_purchase_${date_variant_item[0]};
                    </tal:caboose_variants>
                }
        </tal:buy_menu_lead_unit_only>

    </tal:model_common>
</tal:randomised_caboose>
