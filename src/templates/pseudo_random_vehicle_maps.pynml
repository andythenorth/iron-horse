
<!--! wagons -->

<!--! For some randomised cases, we want runs of the same 'random' vehicle for count n (usually between 2 and 5).
      Then we switch to another 'random' vehicle.
      This achieved using 64 deterministic random maps, which are generated by the compile using a deterministic seed.
      Each map has 64 entries, corresponding to an offset which is used to select a set of random bits from the lead engine.
      -->
<tal:deterministic_random_maps repeat="random_map_type pseudo_random_vehicle_maps.map_configurations.keys()">
    <tal:deterministic_random_maps_by_type repeat="random_map pseudo_random_vehicle_maps.get_deterministic_random_vehicle_maps(random_map_type)">
        <!--! (position_in_consist -1) here because we can assume there's at least one engine ...
               ...we don't try to do anything fancier than that, but this prevents high incidence of a run of just 2 at start of wagons -->
        switch (FEAT_TRAINS, SELF, switch_deterministic_random_vehicle_map_${random_map_type}_${repeat.random_map.index}, [
                (position_in_consist - 1) % 64
            ]) {
            <tal:map_items repeat="map_item random_map">
                ${repeat.map_item.index}: ${map_item};
            </tal:map_items>
        }
    </tal:deterministic_random_maps_by_type>

    <!--! pick 6 bits to choose 1 of 64 maps; the bits do possibly overlap with the variant selection bits in 1 of 10 cases, but we'll live with that -->
    switch (FEAT_TRAINS, PARENT, pseudo_random_value_from_deterministic_random_map_${random_map_type}, [
            getbits(var[0x5F, 8, 0x00FFFFFF], 0, 6)
        ]) {
        <tal:map_indexes repeat="map_index range(64)">
            ${map_index}: switch_deterministic_random_vehicle_map_${random_map_type}_${map_index};
        </tal:map_indexes>
    }

</tal:deterministic_random_maps>


<!--! intermodal cars -->

<tal:deterministic_random_maps repeat="ruleset_map_items pseudo_random_vehicle_maps_intermodal.generate_map_for_ruleset().items()">
    <tal:block define="ruleset_type ruleset_map_items[0];
                       ruleset_maps ruleset_map_items[1]">
        <tal:deterministic_random_maps_by_type repeat="ruleset_map ruleset_maps">
            switch (FEAT_TRAINS, SELF, switch_deterministic_random_vehicle_map_INTERMODAL_${ruleset_type}_${repeat.ruleset_map.index}, [
                    LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % ${len(ruleset_map)}
                ]) {
                <tal:map_entries repeat="map_entry ruleset_map">
                    ${repeat.map_entry.index}: return ${map_entry};
                </tal:map_entries>
            }
        </tal:deterministic_random_maps_by_type>

        switch (FEAT_TRAINS, PARENT, switch_deterministic_random_vehicle_map_INTERMODAL_${ruleset_type}, [
                <!--! 64 maps so pick 6 bits -->
                getbits(var[0x5F, 8, 0x00FFFFFF], 0, 6)
            ]) {
            <tal:map_indexes repeat="map_index range(len(ruleset_maps))">
                ${map_index}: switch_deterministic_random_vehicle_map_INTERMODAL_${ruleset_type}_${map_index};
            </tal:map_indexes>
        }
    </tal:block>
</tal:deterministic_random_maps>


<!--! mail cars -->

<tal:CABBAGE_deterministic_random_maps_MAIL repeat="CABBAGE_random_maps pseudo_random_vehicle_maps_MAIL_CABBAGE.get_all_mail_maps()">
    <tal:cabbage_chain_length repeat="CABBAGE_map CABBAGE_random_maps['maps']">
        switch (FEAT_TRAINS, SELF, switch_deterministic_random_vehicle_map_mail_chain_length_${CABBAGE_random_maps['chain_length']}_map_${repeat.CABBAGE_map.index}, [
                LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % ${len(CABBAGE_map)}
            ]) {
            <tal:map_items repeat="map_item CABBAGE_map">
                ${repeat.map_item.index}: ${map_item};
            </tal:map_items>
        }
    </tal:cabbage_chain_length>

    switch (FEAT_TRAINS, PARENT, pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE_chain_length_${CABBAGE_random_maps['chain_length']}, [
            <!--! up to 32 maps -->
            getbits(var[0x5F, 8, 0x00FFFFFF], 0, 5) % ${len(CABBAGE_random_maps['maps'])}
        ]) {
        <tal:map_indexes repeat="map_index CABBAGE_random_maps['maps']">
            ${repeat.map_index.index}: switch_deterministic_random_vehicle_map_mail_chain_length_${CABBAGE_random_maps['chain_length']}_map_${repeat.map_index.index};
        </tal:map_indexes>
    }
</tal:CABBAGE_deterministic_random_maps_MAIL>

switch (FEAT_TRAINS, PARENT, pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE, target_map_length, [target_map_length]) {
    <tal:length_indexes repeat="CABBAGE_random_maps pseudo_random_vehicle_maps_MAIL_CABBAGE.get_all_mail_maps()">
        ${CABBAGE_random_maps['chain_length']}: pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE_chain_length_${CABBAGE_random_maps['chain_length']};
    </tal:length_indexes>

}


<!--! pax cars -->

<tal:CABBAGE_deterministic_random_maps_PAX repeat="CABBAGE_random_maps_by_category pseudo_random_vehicle_maps_PAX_CABBAGE.get_all_pax_maps().items()">
    <tal:maps_by_category repeat="CABBAGE_random_maps_container CABBAGE_random_maps_by_category[1]"
                          define="category CABBAGE_random_maps_by_category[0]">
        <tal:cabbage_chain_length repeat="CABBAGE_map CABBAGE_random_maps_container['maps']">
            switch (FEAT_TRAINS, SELF, switch_deterministic_random_vehicle_map_pax_category_${category}_chain_length_${CABBAGE_random_maps_container['chain_length']}_map_${repeat.CABBAGE_map.index}, [
                    LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % ${len(CABBAGE_map)}
                ]) {
                <tal:map_items repeat="map_item CABBAGE_map">
                    ${repeat.map_item.index}: ${map_item};
                </tal:map_items>
            }
        </tal:cabbage_chain_length>


        switch (FEAT_TRAINS, PARENT, pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_${category}_chain_length_${CABBAGE_random_maps_container['chain_length']}, [
                <!--! up to 8 maps -->
                getbits(var[0x5F, 8, 0x00FFFFFF], 0, 3) % ${len(CABBAGE_random_maps_container['maps'])}
            ]) {
            <tal:map_indexes repeat="map_index CABBAGE_random_maps_container['maps']">
                ${repeat.map_index.index}: switch_deterministic_random_vehicle_map_pax_category_${category}_chain_length_${CABBAGE_random_maps_container['chain_length']}_map_${repeat.map_index.index};
            </tal:map_indexes>
        }

    </tal:maps_by_category>

    switch (FEAT_TRAINS, PARENT, pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_${CABBAGE_random_maps_by_category[0]}, target_map_length,
            [target_map_length]
        ) {
        <tal:length_indexes repeat="CABBAGE_random_maps CABBAGE_random_maps_by_category[1]">
            ${CABBAGE_random_maps['chain_length']}: pseudo_random_value_from_deterministic_random_map_PAX_CABBAGE_category_${CABBAGE_random_maps_by_category[0]}_chain_length_${CABBAGE_random_maps['chain_length']};
        </tal:length_indexes>
    }


</tal:CABBAGE_deterministic_random_maps_PAX>

