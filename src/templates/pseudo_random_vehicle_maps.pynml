<!--! For some randomised cases, we want runs of the same 'random' vehicle for count n (usually between 2 and 5).
      Then we switch to another 'random' vehicle.
      This achieved using 64 deterministic random maps, which are generated by the compile using a deterministic seed.
      Each map has 64 entries, corresponding to an offset which is used to select a set of random bits from the lead engine.
      -->
<tal:deterministic_random_maps repeat="random_map_type pseudo_random_vehicle_maps.map_configurations.keys()">
    <tal:deterministic_random_maps_by_type repeat="random_map pseudo_random_vehicle_maps.get_deterministic_random_vehicle_maps(random_map_type)">
        <!--! (position_in_consist -1) here because we can assume there's at least one engine ...
               ...we don't try to do anything fancier than that, but this prevents high incidence of a run of just 2 at start of wagons -->
        switch (FEAT_TRAINS, SELF, switch_deterministic_random_vehicle_map_${random_map_type}_${repeat.random_map.index}, (position_in_consist - 1) % 64) {
            <tal:map_items repeat="map_item random_map">
                ${repeat.map_item.index}: ${map_item};
            </tal:map_items>
        }
    </tal:deterministic_random_maps_by_type>

    <!--! pick 6 bits to choose 1 of 64 maps; the bits do possibly overlap with the variant selection bits in 1 of 10 cases, but we'll live with that -->
    switch (FEAT_TRAINS, PARENT, pseudo_random_value_from_deterministic_random_map_${random_map_type}, getbits(var[0x5F, 8, 0x00FFFFFF], 0, 6)) {
        <tal:map_indexes repeat="map_index range(64)">
            ${map_index}: switch_deterministic_random_vehicle_map_${random_map_type}_${map_index};
        </tal:map_indexes>
    }

</tal:deterministic_random_maps>





<tal:CABBAGE_deterministic_random_maps_MAIL repeat="CABBAGE_random_maps pseudo_random_vehicle_maps_MAIL_CABBAGE.get_all_mail_maps()">
    <tal:cabbage_chain_length repeat="CABBAGE_map CABBAGE_random_maps['maps']">
        switch (FEAT_TRAINS, SELF, switch_deterministic_random_vehicle_map_mail_length_${CABBAGE_random_maps['chain_length']}_map_${repeat.CABBAGE_map.index}, [
                LOAD_TEMP(k_addr_position_in_badge_predicate_chain) % ${len(CABBAGE_map)}
            ]) {
            <tal:map_items repeat="map_item CABBAGE_map">
                ${repeat.map_item.index}: ${map_item};
            </tal:map_items>
        }
    </tal:cabbage_chain_length>

    switch (FEAT_TRAINS, PARENT, pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE_length_${CABBAGE_random_maps['chain_length']}, [
            <!--! up to 32 values -->
            getbits(var[0x5F, 8, 0x00FFFFFF], 0, 5) % ${len(CABBAGE_random_maps['maps'])}
        ]) {
        <tal:map_indexes repeat="map_index CABBAGE_random_maps['maps']">
            ${repeat.map_index.index}: switch_deterministic_random_vehicle_map_mail_length_${CABBAGE_random_maps['chain_length']}_map_${repeat.map_index.index};
        </tal:map_indexes>
    }
</tal:CABBAGE_deterministic_random_maps_MAIL>

<!--! old CABBAGE
switch (FEAT_TRAINS, PARENT, pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE, [
            LOAD_TEMP(k_addr_num_vehs_in_badge_predicate_chain) % ${len(pseudo_random_vehicle_maps_MAIL_CABBAGE.get_all_mail_maps())}
        ]) {
    <tal:length_indexes repeat="CABBAGE_random_maps pseudo_random_vehicle_maps_MAIL_CABBAGE.get_all_mail_maps()">
        ${CABBAGE_random_maps['chain_length']}: pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE_length_${CABBAGE_random_maps['chain_length']};
    </tal:length_indexes>

}
-->
switch (FEAT_TRAINS, PARENT, pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE, target_map_length, [target_map_length]) {
    <tal:length_indexes repeat="CABBAGE_random_maps pseudo_random_vehicle_maps_MAIL_CABBAGE.get_all_mail_maps()">
        ${CABBAGE_random_maps['chain_length']}: pseudo_random_value_from_deterministic_random_map_MAIL_CABBAGE_length_${CABBAGE_random_maps['chain_length']};
    </tal:length_indexes>

}
