<tal:railtype_varies_power condition="model_variant.engine_varies_power_by_power_source and unit.is_not_trailing_part">
    <!--! power varies by railtype -->
    <!--! order of power sources is significant here, the switch chain should check highest value first, progressing to lowest
          the python method will return the power sources in the required order -->
    <tal:power_source repeat="power_source_data model_variant.vehicle_power_source_tree">
        switch (FEAT_TRAINS, SELF, ${model_variant.model_id}_switch_power_${power_source_data[2]}, tile_powers_track_type_name_${power_source_data[1]}()) {
            1: return ${model_variant.power_by_power_source[power_source_data[0]]};
            <tal:next condition="power_source_data[3] != None">
                return ${model_variant.model_id}_switch_power_${power_source_data[3]};
            </tal:next>
        }
    </tal:power_source>
</tal:railtype_varies_power>

<tal:distributed_power_wagon condition="model_variant.distributed_power_wagon and unit.is_not_trailing_part">
    <!--! power varies if specific engines are present in the consist -->
    <!--! this is unsophisticated and doesn't bother enforcing that the cab unit must be contiguous with appropriate wagons -->
    <!--! CABBAGE SHOULD BE BADGES NOT UNIT IDS see model type distributed_power_badges-->
    switch (FEAT_TRAINS, PARENT, ${model_variant.model_id}_switch_power_0, [
            count_veh_id(${model_variant.cab_engine.units[0].id}) > 0
        ]) {
        1: return ${model_variant.cab_power};
        return 0;
    }
</tal:distributed_power_wagon>
