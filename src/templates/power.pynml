<tal:railtype_varies_power condition="model_variant.engine_varies_power_by_power_source and unit.is_not_trailing_part">
    <!--! power varies by railtype -->
    <!--! order of power sources is significant here, the switch chain should check highest value first, progressing to lowest
          the python method will return the power sources in the required order -->
    <tal:power_source repeat="power_source_data model_variant.vehicle_power_source_tree">
        switch (FEAT_TRAINS, SELF, ${model_variant.model_id}_switch_power_${power_source_data[2]}, [
                ${power_source_data[1]}
            ]) {
            1: return ${model_variant.power_by_power_source[power_source_data[0]]};
            <tal:next condition="power_source_data[3] != None">
                return ${model_variant.model_id}_switch_power_${power_source_data[3]};
            </tal:next>
        }
    </tal:power_source>
</tal:railtype_varies_power>

<tal:is_distributed_power_wagon condition="model_variant.is_distributed_power_wagon and unit.is_not_trailing_part">
    <!--! power varies if specific engines are present in the consist -->
    <!--! this is unsophisticated and doesn't bother enforcing that the cab unit must be contiguous with appropriate wagons -->
    switch (FEAT_TRAINS, PARENT, ${model_variant.model_id}_switch_power_0, has_badge("ih_distributed_power/is_power_cab/${catalogue.cab_engine_model.model_id}")) {
        1: return ${catalogue.cab_engine_model.power};
        return 0;
    }
</tal:is_distributed_power_wagon>
