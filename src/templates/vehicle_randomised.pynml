<tal:model_common condition="model_variant.is_default_model_variant">
    <!--! as of Sept 2024, this was simplified to always use python generated pseudo-random maps -->
    switch (FEAT_TRAINS, SELF, ${unit.unit_id_from_common_model_id}_switch_graphics_variant_choose_randomised_wagon, [
                                pseudo_random_value_from_freight_entropic_map_${model_variant.gestalt_graphics.random_vehicle_map_type}()
                                <!--! modulo to cap the value selected (range 64) to the range of actual candidates -->
                                %
                                ${len(model_variant.wagon_randomisation_candidates)}
        ]) {
        <tal:randomisation_candidates repeat="randomisation_candidate model_variant.wagon_randomisation_candidates">
            ${repeat.randomisation_candidate.index}: ${repeat.randomisation_candidate.index};
        </tal:randomisation_candidates>
    }
    <!--! note that we provide '_switch_graphics' not '_switch_graphics_vehicle' as there are no precursor graphics entry switches for randomised wagons
          we'll ultimately chain instead to the selected candidate's graphics entry switch
          note that graphics_entry_switches.pynml shouldn't be used with this template
          randomised vehicles chain via the selected candidate's graphics entry switch, so they don't need their own graphics entry switch  -->
    switch (FEAT_TRAINS, SELF, ${unit.unit_id_from_common_model_id}_switch_graphics,
                ${unit.unit_id_from_common_model_id}_switch_graphics_variant_choose_randomised_wagon()) {
        <tal:randomisation_candidates repeat="randomisation_candidate model_variant.wagon_randomisation_candidates">
            <!--! the id interpolation is JFDI
                - possibly should be using unit.unit_index_in_model_variant instead of model_variant.units.index(unit)
                - or possibly it should at least by using unique_units
                - may not matter for non-articulated cases
                - this is untested with articulated vehicles and random articulated vehicles may simply not work at all -->
            <tal:candidate_graphics_entry_cases switch="randomisation_candidate.gestalt_graphics.variants_use_common_graphics_switch_chain">
                <tal:case tal:case="True">
                    ${repeat.randomisation_candidate.index}: ${randomisation_candidate.model_id}_unit_${model_variant.units.index(unit)}_switch_graphics;
                </tal:case>
                <tal:case tal:case="False">
                    ${repeat.randomisation_candidate.index}: ${randomisation_candidate.units[model_variant.units.index(unit)].id}_switch_graphics;
                </tal:case>
            </tal:candidate_graphics_entry_cases>
        </tal:randomisation_candidates>
    }
</tal:model_common>

<tal:buy_menu_lead_unit_only condition="unit.is_not_trailing_part">
    <tal:model_common condition="model_variant.is_default_model_variant">
        <!--! purchase sprites always go through a switch in case the template does anything specific for purchase graphics
              when there is nothing specific, then this is just a null switch -->
        spriteset(${model_variant.model_id}_ss_purchase, "${graphics_path}${model_variant.model_id}.png") {
            ${model_variant.get_nml_for_spriteset_template(y_offset=0)}
        }
        switch (FEAT_TRAINS, SELF, ${model_variant.model_id}_unit_0_switch_graphics_purchase, vehicle_type_id) {
            <!--! all variants of randomised vehicles use the same common purchase sprite -->
            ${model_variant.model_id}_ss_purchase;
        }
    </tal:model_common>
</tal:buy_menu_lead_unit_only>


