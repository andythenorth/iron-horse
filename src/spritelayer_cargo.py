import global_constants  # expose all constants for easy passing to templates

from spritelayer_cargos import registered_spritelayer_cargos


class SpritelayerCargo(object):
    """Simple generic class for spritelayer cargos"""

    def __init__(self, **kwargs):
        self.base_id = None  # set by subclass
        self.platform_type = kwargs.get("platform_type")
        self.length = kwargs.get("length")
        self.cargo_sets = []
        # option to fill in gaps in container shadows
        self.provide_container_shadows = kwargs.get("provide_container_shadows", False)
        # configure gestalt_graphics in the subclass
        self.gestalt_graphics = None

    @property
    def floor_height_for_platform_type(self):
        # crude resolution of floor height for each platform type
        return self.all_platform_types_with_floor_heights[self.platform_type]

    @property
    def id(self):
        return self.base_id + "_" + self.platform_type + "_" + str(self.length) + "px"

    def render(self, templates, graphics_path):
        # templating
        template_name = "spritelayer_cargo.pynml"
        template = templates[template_name]
        nml_result = template(
            temp_storage_ids=global_constants.temp_storage_ids,  # convenience measure
            graphics_path=graphics_path,
            spritelayer_cargo=self,
        )
        return nml_result


class CargoSetBase(object):
    # provides sets of cargo sprites of specific appearance e.g. tank container, flatrack container etc
    # each set corresponds to a spritesheet which will be generated by the graphics processor
    # each set is used for a specific group of cargo labels or classes
    # each set may have one or more spriterows
    # spriterows are chosen randomly when vehicles load new cargo
    # rows are composed by the graphics processor, and may include variations for
    # - combinations of cargo lengths
    # - combinations of cargo types
    # - cargo colours
    def __init__(self, **kwargs):
        self.subtype = kwargs.get("subtype")
        self.subtype_suffix = kwargs.get("subtype_suffix")
        # self.spritelayer_cargo = kwargs.get("spritelayer_cargo")
        self.register_cargo_set(kwargs.get("spritelayer_cargo_type"))

    def register_cargo_set(self, spritelayer_cargo_type):
        for platform_type in self.compatible_platform_types:
            spritelayer_cargo = spritelayer_cargo_type(
                platform_type=platform_type,
                length=self.length,
            )
            # the spritelayer_cargo may already be registered, this is a valid side effect of the implementation
            # but we don't want to register the same spritelayer_cargo multiple times (waste of compile time and can cause bugs with multiprocessing)
            already_registered = False
            for registered_spritelayer_cargo in registered_spritelayer_cargos:
                if registered_spritelayer_cargo.id == spritelayer_cargo.id:
                    already_registered = True
                    spritelayer_cargo = registered_spritelayer_cargo
                    break
            if already_registered == False:
                registered_spritelayer_cargos.append(spritelayer_cargo)
            # print("registering", spritelayer_cargo.id, spritelayer_cargo.platform_type, self.subtype, self.subtype_suffix)
            spritelayer_cargo.cargo_sets.append(self)

    def id(self, spritelayer_cargo):
        return (
            spritelayer_cargo.base_id
            + "_"
            + spritelayer_cargo.platform_type
            + "_"
            + self.subtype
            + "_"
            + self.subtype_suffix
            + "_"
            + str(spritelayer_cargo.length)
            + "px"
        )
