import shutil
import os

currentdir = os.curdir
from time import time

import sys

sys.path.append(os.path.join("src"))  # add to the module search path

import codecs  # used for writing files - more unicode friendly than standard open() module

import iron_horse
import global_constants
import utils
from utils import timing

# setting up a cache for compiled chameleon templates can significantly speed up template rendering
chameleon_cache_path = os.path.join(
    currentdir, global_constants.chameleon_cache_dir
)
# exist_ok=True is used for case with parallel make (`make -j 2` or similar), don't fail with error if dir already exists
os.makedirs(chameleon_cache_path, exist_ok=True)
os.environ["CHAMELEON_CACHE"] = chameleon_cache_path

# setup the places we look for templates
from chameleon import PageTemplateLoader
templates = PageTemplateLoader(os.path.join(currentdir, "src", "templates"), format="text")

# get args passed by makefile
command_line_args = utils.get_command_line_args()

def render_lang(roster, lang_name, lang_dst, git_tag_or_version):
    lang_data = roster.get_lang_data(lang_name, context="grf")
    lang_template = templates["lang_file.pylng"]
    # flatten the strings for rendering
    lang_strings_formatted_as_lng_lines = []
    longest_string_length = max([len(key)] for key in lang_data["lang_strings"].keys())[
        0
    ]

    for string_name, string_value in lang_data["lang_strings"].items():
        # note that stupid pretty formatting of generated output is just to ease debugging string generation when needed, otherwise not essential
        separator = ":".rjust(longest_string_length - len(string_name) + 7)
        lang_strings_formatted_as_lng_lines.append(
            string_name + separator + string_value
        )

    lang_content = utils.unescape_chameleon_output(
        lang_template(
            command_line_args=command_line_args,
            git_tag_or_version=git_tag_or_version,
            utils=utils,
            roster=roster,
            lang_data=lang_data,
            lang_strings_formatted_as_lng_lines=lang_strings_formatted_as_lng_lines,
        )
    )
    # we clean up some templating artefacts just to produce more readable output for debugging when needed, otherwise not essential
    lines = lang_content.split("\n")
    stripped_lines = [line.lstrip() for line in lines]
    cleaned_lang_content = "\n".join(stripped_lines)
    # write the output eh
    dst_file = codecs.open(os.path.join(lang_dst, lang_name + ".lng"), "w", "utf8")
    dst_file.write(cleaned_lang_content)
    dst_file.close()


def main():
    globals()['logger'] = utils.get_logger(__file__)
    logger.info(f"[RENDER LANG] {' '.join(sys.argv)}")
    start = time()
    iron_horse.main()

    roster = iron_horse.roster_manager.active_roster
    # expect Exception failures if there is no active roster, don't bother explicitly handling that case

    lang_dst = os.path.join(
        iron_horse.generated_files_path, "lang", command_line_args.grf_name
    )
    if os.path.exists(lang_dst):
        shutil.rmtree(lang_dst)
    os.makedirs(lang_dst)

    hint_file = codecs.open(
        os.path.join(lang_dst, "_lang_files_here_are_generated.txt"), "w", "utf8"
    )
    hint_file.write(
        "Don't edit the lang files here.  They're generated by the build script. \n Edit the files in src/lang/ instead."
    )
    hint_file.close()

    # we'll try and read any toml file in the lang dir, this requires that no other toml files are present there
    # possibly the installed languages should be handled by the roster when it parses the toml, not sure eh? (potato / potato?)
    for file_name in os.listdir(os.path.join("src", "lang")):
        # skip the file used to suppress selected strings in selected contexts
        if file_name == "suppressed_strings.toml":
            continue
        if file_name.endswith(".toml"):
            lang_name = file_name.split(".")[0]
            render_lang(roster, lang_name, lang_dst, utils.git_tag_or_version())

    logger.info(
        f"[RENDER LANG]"
        f"{command_line_args.grf_name} - complete "
        f"{utils.string_format_compile_time_deltas(start, time())}"
    )


if __name__ == "__main__":
    main()
